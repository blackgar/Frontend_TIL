# HTML&CSS 전체 질문 정리

<details>
<summary></summary>
</details>

<details> 
<summary>px, em, rem 의 차이에 대해 설명해주세요.</summary>

### px

- px은 우리가 흔히 알고 있는 픽셀값을 나타낸다. 화면 해상도가 1920\*1080일 때 너비(width) 1920px이고 높이(height) 1080px이 된다.

### %

- %는 사용자가 보이는 화면에서 태그가 차지하는 비중을 나타냅니다. 부모가 만들어준 공간안에서의 너비 비율이 정확한 표현입니다. 예를 들어 p태그가 있고 p태그에 70% 속성을 부여했다면, p태그의 부모가 body일 경우 body 너비의 70%만 차지한 상태로 화면에 보여지게 됩니다.

### em

- em은 em단위가 있는 곳의 폰트사이즈의 배수입니다.즉, 상위 요소의 폰트 사이즈를 상속받는다는 것입니다.

```
html{  font-size : 10px;  }
div {  font-size : 2em;  /* 10px의 2배 */  }
li  {  font-size : 2em;  /* 10px의 2배의 2배 */  }

<html> 폰트 10
    <div> 폰트 20
        <li>폰트 40</li>
    </div>
</html>
```

- 위의 예시처럼 div태그는 html태그로부터 폰트사이즈를 상속받아 2\*10px이 2em의 값이 되고 li태그는 div태그의 20px을 상속받아 2em이 20\*2px인 40px이 됩니다.

### rem

- rem은 상위 요소의 영향을 받지 않고 최상위 요소의 폰트사이즈를 기준으로 단위가 정해집니다. 즉 root 요소의 폰트사이즈가 16px이라면 1rem의 값은 16px로 고정이 되고 이 수치를 변경하고 싶다면 root 요소의 폰트사이즈를 변경해주면 됩니다.
  </details>

<details>
<summary>반응형 웹을 구현할 때는 이 단위 중에서 어떤 단위를 주로 사용하시나요?</summary>
- rem을 주로 사용하고 있습니다. 요소의 depth가 깊어질수록 em은 관리하기 어렵다는 단점이 있어서 빠르게 UI를 구성하고 반응형을 작업할 때는 rem을 통해서 좀 더 효율적으로 개발을 하려고 하고 있습니다.
</details>

<details>
<summary>vw, vh에 대해 설명해주세요.</summary>

### vw, vh란?

> vh = viewport height, vw = viewport width

- vw와 vh는 현재 실행중인 스크린 크기에 맞춰 상대적 크기를 반환하겠다는 의미의 프로퍼티입니다. 100vh, 100vw가 전체 화면의 기준이 됩니다. 현재 스크린 크기가 1920\*1080일때 1vh는 19.2px 1vw는 10.8px이 된다는 의미입니다.

### %와의 차이

- vh를 width에 vw를 height에 사용할 수 있습니다.
- vh와 vw는 열려있는 화면 전체의 상대길이이기 때문에 스크롤바를 포함한 길이를 반환한다는 특징을 가집니다. 반면에 %는 스크롤 바를 포함하지 않은 현재 화면 길이를 반환하고 %를 쓰고있는 요소의 부모 요소의 길이에 맞게 반환되는 차이가 있습니다.

### vmin, vmax

- vmin, vmax라는 요소가 있는데 viewport 길이 중 더 긴 길이가 vmax, 더 짧은 길이가 vmin이 된다.

</details>

## 반응형 브레이크 포인트는 보통 어떻게 잡으시나요?

- 반응형 브레이크 포인트는 일반적으로 데스크탑과 모바일로 먼저 나누어서 두 구간으로 잡은 다음 추가적으로 태블릿이나 작은 사이즈의 모니터로 추가적으로 반응형을 나누었습니다.

## CSS 선택자의 우선순위에 대해 설명해주세요.

- css 선택자는 각 선택자별로 점수가 있고 점수가 높은 선언이 우선하는 것이 원칙입니다. 또한, 점수가 같을 때는 가장 마지막에 작성된 선언이 우선해서 적용됩니다.
- !important : 무한대
- 인라인 선언 방식 : 1000점
- id선택자 : 100점
- class선택자 : 10점
- 태그선택자 : 1점
- 전체선택자 : 0점
- 부정 선택자 : 0점

- ex) .list li.item => 클래스 + 태그 + 클래스 = 10 + 1 + 10 => 21점
- ex) .list li:hover => 클래스 + 태그 + 클래스 = 10 + 1 + 10 => 21점
- ex) .box::before => 클래스 + 태그 = 10 + 1 => 11점
- ex) #submit span => id + 태그 = 100 + 1 => 101점
- 위 예시에서는 #submit span이 가장 먼저 적용된다는 것을 알 수 있고 .box::before이 마지막으로 적용됩니다. 첫 번째와 두 번째 선택자의 경우 두번째 선택자가 뒤에 작성됐기 때문에 먼저 적용됩니다.

## 페이지 크기가 변해도 항상 같은 비율을 유지하는 요소를 만들려면 CSS를 어떻게 설정해야될까요?

- % 지정을 통해서 부모 요소에 맞게 하위 요소들이 비율에 맞게 변할 수 있도록 지정해주면 됩니다.

## Flexbox에 대해 설명해주세요.

- 일반적으로 하나의 Flex container과 Flex item으로 구성됩니다. container에서는 flex-direction, justify-content, align-items와 같은 속성을 적용시킬 수 있고 flex item에서는 flex, align-self, order와 같은 속성을 적용할 수 있습니다.

## float의 동작에 대해 설명해주세요.

- 레이아웃을 구성할 때 블록 레벨 요소를 가로 정렬하기 위해서 사용되는 기법입니다. float, clear, overflow 세가지 속성으로 동작을 하게 됩니다.
- float는 해당 요소를 다음 요소 위에 떠 있게 하는데, 요소가 기본 레이아웃의 흐름에서 벗어나 요소의 모서리가 페이지의 왼쪽이나 오른쪽으로 이동하게 하는 것입니다. left, right, none 세가지 프로퍼티가 있습니다.
  - left : 왼쪽부터 가로정렬
  - right : 오른쪽부터 가로정렬
  - none : 부유하지 않게 설정
- clear 속성은 float속성이 적용된 이후에 나타나는 요소들의 동작을 조절해줍니다. 즉, float 속성이 필요한 요소가 끝났다면 이후 요소부터는 float의 영향을 받지 않도록 해주는 프로퍼티입니다.
- overflow 속성은 float 속성이 적용된 요소가 자신을 감싸고 잇는 컨테이너 요소보다 커지게 될경우 일부가 밖으로 흘러넘치게 되는데 overflow auto를 주게 되면 컨테이너 요소의 크기가 자동적으로 모두를 감쌀 수 있을 만큼 커지게 만들어줍니다.

## CSS에서 Cascading에 대해 설명해주세요.

- HTML 요소는 스타일에 대해서 여러 스타일을 적용 받을 수 있는데, 어느 스타일을 적용 받을지에 대한 우선순위를 정하게끔 하는 것입니다. CSS가 어디에 선언되어있는가(중요도, 어느 태그안에 style이 적용되어 있는가), 대상을 명확하게 지정할수록 높은 우선순위를 지닌다(명시도, css 선택자), 코드 순서(css 선택자 점수가 같을 때 어느 위치에 작성되었는가) 이 세가지에 의해서 cascading이 정해지게 됩니다.

## ⭐ SCSS에 대해 설명해주세요.

- 기존의 css가 프로젝트 규모가 커지거나 UI가 복잡해질 경우 가독성을 떨어뜨린다는 문제를 해결하기 위해서 코드의 가독성과 재사용성을 높여주면서 간단한 표기법으로 CSS 구조를 개선한 방식입니다.
- CSS 내부에 변수를 할당하거나, 중첩구문, 모듈화, 믹스인, 확장과 상속, 그리고 연산자를 활용할 수 있는 기능을 제공해줍니다.

## ⭐ postition 속성에 대해 설명해주세요.

- position 속성은 태그를 어떻게 위치시킬 것인지에 대한 정의를 내리는 속성값으로 5가지의 속성값을 가집니다. position 속성은 상속되지 않는다.
  - static : 기본값으로 다른 태그와의 관계에 의해 자동으로 배치되기 때문에 위치를 임의로 설정할 수 없습니다.
  - absolute : 절대 좌표와 함께 위치를 지정해줄 수 있습니다.(top, left, right, bottom). 해당 아이템이 담겨있는 박스(부모) 안에서 기준으로 위치 값이 변경된다는 특징이 있고 relative인 부모를 찾아서 계속 위로 이동. 없으면 0, 0으로 고정
  - relative : 원래 있던 위치를 기준으로 좌표를 지정합니다.
  - fixed : 스크롤과 상관없이 항상 문서 좌측최상단을 기준으로 좌표를 고정합니다. 즉 브라우저(윈도우)를 기준으로 위치 변경이 일어납니다.
  - sticky : 부모 요소 안에서의 현재 자신의 위치에 고정된다. top, left, bottom, right을 지정해줘야한다.
  - \* absolute나 fixed 속성 지정시 가로 크기가 100%가 되는 block태그의 특징이 사라지게 됩니다.

## Box model에 대해 설명해주세요.

- CSS는 요소를 표시하기 위해서 요소별로 사각형의 박스를 생성합니다. 박스의 크기는 콘텐츠 크기의 안쪽여백인 padding과 테두리인 border 그리고 바깥 여백인 margin에 의해 결정됩니다.
  - content : 요소의 콘텐츠가 표시되는 영역
  - padding : content 영역과 border 사이의 안쪽 여백
  - border : padding 영역과 margin 사이의 테두리
  - margin : border를 기준으로 다른 요소와의 바깥쪽 여백

## margin과 padding에 대해 설명해주세요.

- padding : content영역과 border 사이의 안쪽 여백을 지정하는 속성(음수값 사용x).
- margin : border을 기준으로 다른 요소와의 바깥쪽 여백을 지정하는 속성(음수값 사용o)

## ⭐ display 속성에 어떤 것들이 있는지 설명해 주세요.

- 여러 속성이 있지만 대표적으로 사용하는 것들에 대해서 설명드리겠습니다.
- display:none : 요소를 렌더링하지 않도록 설정하기 때문에 visibility:hidden과 달리 영역도 차지하지 않습니다.

```
<style>
.display-none{ display: none }
.visibility-hidden{ visibility: hidden }
</style>

<div class="display-none">1</div>
<div>2</div>
<div class="visibility-hidden">3</div>
<div>4</div>

출력결과
2

4
```

- display:inline : Span, a, b, i, img 등의 태그가 이에 해당합니다. block과 달리 줄 바꿈이 되지 않으며 width와 height 그리고 여백을 지정할 수 없습니다.
- display:block : div, p, h, li, form 등의 태그가 이에 해당합니다. 가로 영역을 모두 차지하면서 항상 줄바꿈이 발생합니다. width, height 그리고 여백을 지정할 수 있습니다.
- display:inline-block : 요소 자체는 inline처럼 동작하지만, 해당 요소 내부에서는 블록 요소처럼 동작합니다.(줄바꿈x, 크기나 여백 지정 가능)
- display:flex : 아이템들을 가로 or 세로 방향으로 배치할 수 있는 방식으로 요소의 크기가 불분명하거나 동적인 경우에도 각 요소를 정렬할 수 있는 효율적인 방법을 제공합니다.
- display:grid : Flex와는 다르게 2차원으로 배치하는 방식으로 column과 row의 비율이나 크기를 지정합니다. grid-template-rows는 가로에 배치할 셀들의 비율이나 크기를 지정하는 속성이고 grid-template-columns는 세로로 배치할 셀들의 비율이나 크기를 나타냅니다.
- display:table : 레이아웃을 table로 표현할 수 있는 속성이다.
  - display : table // table 요소처럼 표현하기
  - display : table-row // tr 요소처럼 표현하기
  - display : table-column // col 요소처럼 표현하기
  - display : table-cell // td 요소처럼 표현하기
  - display : table-caption // caption요소처럼 표현하기

## HTML 렌더링 도중 JavaScript가 실행되면 렌더링이 멈추는 이유가 뭔가요?

- 브라우저가 렌더링 되는 과정은

#### 랜더링 과정

1. 사용자가 브라우저에 검색어를 입력한다.
2. 이 검색어가 검색어인지 url인지 판단해서 검색어인 경우 검색 엔진 URL에 검색어를 결합해서 페이지 이동을 시작하고, url이라면 네트워크 호출을 수행합니다. 이 때 로딩 화면과 동시에 네트워크 스레드는 적절한 프로토콜로 요청을 처리하기 시작.
3. 응답이 도착하기 시작하면 HTML/PDF 형식의 경우 렌더러 프로세스에서 처리하고 다운로드 파일의 경우 다운로드 매니저에게 데이터를 전달하고 이와 동시에 해당 사이트가 악성 페이지인지에 대한 검사가 이루어진다.
4. 모든 검사가 끝나면 네트워크 스레드는 UI 스레드에 작업 준비 완료를 알리고 UI 스레드는 웹 페이지를 렌더링할 렌더러 프로세스를 찾기 시작한다.
5. 네트워크 요청이 오래 걸릴 수 있으므로 URL 요청을 보낼 때 UI 스레드가 미리 렌더링을 수행할 프로세서를 찾아놓는 최적화가 되어 있는 경우도 있다.
   주요 렌더링 경로(Critical Rendering Path, CRP)

- HTML, CSS파싱 => DOM, CSSOM트리, 렌더 트리 생성¬¬¬¬¬¬¬¬
- 레이아웃(각 요소의 상대적인 위치, 크기를 찾는 과정, 왼->오, 위->아래), 레이아웃 이후 DOM 노드가 추가되거나 변경될 경우 글로벌 레이아웃 & 로컬 레이아웃 두 가지 과정으로 나타난다.
- 페인트
- 합성 (각 레이어를 래스터화한 뒤 페이지 크기/뷰포트에 맞게 합성해 화면으로 나타내기)

6. 데이터와ㅣ 렌더러 프로세스가 준비되면 본격적으로 페이지 이동이 시작. 이 시점에 렌더러 프로세스는 HTML 데이터를 수신해 문서를 로딩하고 브라우저의 주소 표시줄, 사이트 제목 등의 UI도 같이 갱신. 이와 동시에 탭을 이동할 수 있도록 세션 기록도 저장한다.
7. 렌더링이 완료되면 렌더러 프로세스가 브라우저 프로세서로 로딩 완료를 알리고 UI 스레드의 로딩 표시 중지

## Attribute와 Property의 차이에 대해 설명해주세요.

- attribute : HTML마크업(텍스트 문서)에 정의되어 있는 것이고, HTML 요소의 추가적인 정보를 전달하고 이름="값" 이렇게 쌍으로 오고 이때의 값은 전달받은 이후 고정된다는 특징이 있습니다.
- property : HTML DOM 트리에 정의되어 있는 것입니다. 그래서 전달받은 값이 변경되면 같이 변경되는 특징이 있습니다.

```
<input value="default" />

console.log(input.getAttribute("value")) // default
console.log(input.value) // default

input에 change라고 입력 시
console.log(input.getAttribute("value")) // default
console.log(input.value) // change
```

## CSS 애니메이션과 JS 애니메이션의 차이에 대해서 설명해 주세요.

- CSS 애니메이션 : transition / animation 속성 등을 사용할 수 있습니다. 일반적으로 간단하게 처리하는 애니메이션의 경우 CSS로 처리합니다. 예를 들어 transform의 translate를 사용해서 구현할 수 있는 애니메이션을 JS의 style.top과 style.left 속성 변화로 구현할 경우 브라우저 렌더링 과정에서 layout이나 paint 단계를 거쳐야 할 경우가 생기므로 성능 개선에 좋지 않습니다.
  - 외부 라이브러리를 필요로 하지 않습니다.
  - 어떤 요소가 애니메이션을 가져야 한다는 직과적인 표현이 가능합니다.
  - 미디어쿼리를 통한 반응형 애니메이션 구현이 가능합니다.
  - 메인쓰레드가 아니라 별도의 컴포지터 쓰레드에서 그려지기에 메인 쓰레드에서 작업하는 JS보다 효율적입니다.
- JS 애니메이션 : setInterval() / requestAnimationFrame()을 사용할 수 있습니다. CSS로만 처리하기에는 무거운 애니메이션 작업들을 효율적이고 세밀하게 다루기 위해서 사용합니다. JS로 구현할 경우 요소의 위치를 재계산하기에 비효율적인 것이라 60FPS를 유지하지 못하기 때문에 RAF(RequestAnimationFrame)가 등장했습니다.
  - 애니메이션의 세밀한 제어가 필요한 경우에 JS를 사용합니다.
  - 크로스 브라우징 측면에서 JS 애니메이션이 브라우저 호환성이 좋아 유리합니다.
  - GPU를 통한 하드웨어 가속을 활용할 수 있습니다.

## CSS in JS의 장단점에 대해 설명해주세요.

- 최근 여러가지 CSS-in-JS 라이브러리가 등장하고 있는데, 일반적으로 javascript runtime에 필요한 css를 동적으로 만들어서 적용합니다. styled-component와 emotion이 대표적인 예시인데, 일정 요소의 상태가 바뀌면 style 코드가 동적으로 생성되어 삽입됩니다. 그렇기 때문에 CSS 파일을 직접 생성하지 않기 때문에 webpack에 css-loader가 필요없게 됩니다. 하지만, 런타임 오버헤드가 발생할 수 있습니다. 런타임에서 동적으로 스타일을 생성하기 때문에 스타일이 수시로 변경된다면 문제가 발생할 수 있습니다.(ex) 스크롤, 드래그 앤 드랍 관련 복잡한 애니메이션)

- 기존의 문제
  - CSS 속성의 중복과 재사용성이 떨어진다는 문제
  - inline-style로는 의사 클래스, 의사 요소, 미디어 쿼리, 키 프레임 애니메이션과 같은 CSS의 기능을 활용할 수 없다는 문제
  - 앱의 규모가 커질수록 유지 보수가 어렵다는 문제
  - 인라인 스타일이 많으면 코드 가독성이 떨어진다는 문제
  - inline style은 인라인 태그로 style을 정의하는 반면 CSS-in-JS는 style 태그를 따로 정의하고 해당 태그에 class화 시켜서 연결하는 방식으로 동작해서 훨씬 효율적입니다.
- 장점(아래 이슈 해결)
  - CSS 컴포넌트화로 스타일시트의 파일을 유지보수할 필요가 없습니다. CSS 모델을 문서레벨이 아니라 컴포넌트 레벨로 추상화할 수 있습니다.(모듈화)
  - Javascript 환경을 최대한 활용할 수 있다는 장점이 있습니다.(중복된 속성들을 하나의 변수로 관리 가능 등)
  - JS와 CSS 사이의 상수와 함수를 쉽게 공유할 수 있습니다.
  - 현재 사용중인 스타일만 DOM에 포함합니다.
  - 짧은 길이의 유니크한 클래스를 자동으로 생성해주기 때문에 코드 경량화의 장점이 있습니다.
- 단점
  - 러닝 커브가 있습니다.
  - 새로운 의존성이 생겨납니다.
  - 별도의 라이브러리를 설치해야 해 번들 크기가 커집니다.
  - 인터랙션 페이지를 만들 경우 CSS 파일을 따로 관리하는 방법에 비해 느린 성능을 보여줄 수 있습니다.

## ⭐ 시맨틱 마크업에 대해 설명해주세요.

- 작성한 내용을 잘 전달할 수 있도록 문서를 작성하는 방법을 뜻합니다.
- 시멘틱 마크업을 하기 위해서는 우선 각 태그를 그 용도에 맞게 사용해야 합니다.
  - 헤더/푸터에 <header>와 <footer> 사용
  - 메인 컨텐츠에 <main>과 <section> 사용
  - 독립적인 컨텐츠에 <article> 사용
  - 최상위 제목으로 <h1> 사용
  - 순서가 없는 목록으로 <ul>과 <li> 사용
  - 내비게이션에 <nav>사용
- CSS 스타일을 명시하는 태그를 사용하지 않도록 하는 방법도 있습니다. 예를 들어 <b>의 경우 그냥 단순히 글자색을 진하게 하지만 <strong>은 그 안의 내용을 더 강조한다는 의미도 포함되어 있으므로 시맨틱 마크업에 더 적합합니다.
- 또한, 검색엔진은 시맨틱 태그로 중요 키워드를 간주하기 때문에 SEO를 위해서는 시멘틱 마크업이 필요합니다.
- 웹 접근성 측면에서도 장애가 있는 사람들도 웹 페이지 서비스를 동일하게 사용할 수 있어야 하는데, 스크린 리더나 음성인식 등 장애인들을 위해 필요한 기능들의 경우 시멘틱 태그로 작성된 내용들을 더 정확하게 읽어주거나 확인시켜주기 때문에 필요합니다.

## HTML5의 태그에 대해 설명해주세요.

- HTML이란?

  - 웹페이지를 만드는 마크업 언어입니다. HTML 마크업을 통해서 웹페이지의 구조를 설계합니다.
  - HTML 요소들은 웹 페이지를 구성하는 요소이며, 태그를 사용해 표현할 수 있습니다.
  - 태그들은 각자의 기능과 의미를 가지고 웹페이지의 내용을 보여줍니다.

- HTML5란?
  - HTML5 이전에는 같은 웹 사이트라도 브라우저에 따라 화면이 다르게 보이는 문제가 있었는데 이로 인해 웹 표준의 필요성이 요구된 상황에서 이를 충족시키기 위한 기술로 HTML5가 등장하게 됐습니다.
- 특징
  - HTML5부터는 플러그인의 추가 설치 없이 동영상이나 음악을 웹 브라우저 상에서 곧바로 재생이 가능해졌습니다.
  - SVG 태그를 이용한 2차원 벡터 그래픽과 자바 스크립트 캔버스를 이용한 2차원 래스터 그래픽, CSS3와 자바스크립트 WebGL을 사용한 3차원 그래픽의 구현이 가능해졌습니다.
  - 서버와 소켓 통신을 통해 실시간으로 서버와 양방향 통신이 가능해졌습니다.
  - 스마트폰의 배터리 잔량을 확인하거나 GPS를 통한 위치 확인 및 장치 접근이 가능해졌습니다.
  - 오프라인 상태에서도 개발작업이 가능해졌습니다.
  - WebStorage를 활용해 웹페이지의 내용을 로컬브라우저에 데이터를 저장할 수 있습니다.
- HTML4와의 차이

  - 이전 버전보다 정보 구조를 작성하는데 유리해졌습니다. div태그 대신 header, nav, section, article, aside, footer 등을 이용해 구체적인 구조를 만들 수 있습니다.
  - Syntax(구문)
  - Language(언어)
  - API

- 태그란?
  - 일반적으로 요소, element라고 합니다. HTML문서를 이루는 중요한 요소로 태그마다 각기 다른 의미와 역할 구조를 가지고 있습니다. 웹페이지의 내용과 구조에 맞게 태그가 가지는 의미와 역할을 고려해서 적절하게 사용해 개발을 진행해야 합니다. 시멘틱 마크업을 지키면서 태그를 사용하는 것이 웹 접근성과 SEO에 유리할 수 있습니다. 태그는 대소문자 구문을 하지 않지만 소문사 사용을 권고합니다.

## script 태그에서 Async와 Defer의 차이에 대해 설명해주세요.

- async : boolean 타입이기 때문에 선언하는 것만으로도 true로 사용 가능합니다. 브라우저가 HTML을 파싱하다가 async를 확인하고 병렬로 다운로드를 명령만 하고 다시 파싱을 하면서 JS파일이 다운로드 되면 그때 파싱을 멈추고 다운로드된 JS파일을 실행하고 다되면 나머지 HTML을 파싱하게 됩니다. 다운받는 속도를 절약할 수 있지만 HTML이 파싱되기도 전에 실행이 되기 때문에 querySelector로 DOM을 조작할 때 위험할 수 있으며 HTML을 파싱하는 동안 언제든지 자바스크립트를 실행하기 위해서 멈출 수 있기 때문에 사용자가 페이지를 보는데 불편함이 생길 수 있습니다.(중요한 내용이 먼저 보여져야하는데 보여지지 않기 때문)
- HTML을 파싱하다가 defer을 확인하고 JS파일 다운로드를 명령시킨 후 나머지 HTML을 끝까지 파싱한 다음 JS파일을 실행한다.

- 차이
  - async 옵션으로 다수의 script 파일들을 다운받게 되면 정의된 script 순서에 상관없이 다운로드 된 파일을 우선적으로 실행하기 때문에 JS파일이 순서에 의존적이라면 문제가 발생할 수 있습니다. 이를 방지하기 위해 use strict 사용
  - defer의 경우 모든 script를 다운로드 한 다움에 실행되기에 안전합니다.

## 가상 클래스(pseudo-class)에 대해 설명해주세요.

- html 문서의 수정없이 css만으로 디자인적인 요소를 추가할 수 있도록 해주는 클래스입니다. 선택자에 추가하는 키워드로, 선택한 요소가 특별한 상태여야 만족할 수 있습니다. ex):hover

## margin 병합에 대해 설명해주세요.

- 마진 병합 현상은 인접하는 블록 요소의 상하단의 마진이 병합되는 현상을 일컫습니다. 마진의 크기는 병합되는 마진 중에서 큰 값을 가진 마진의 값으로 병합됩니다. css는 문서를 안정적이고 보기 편하게 하기 위해서 의도적으로 margin 값이 겹치도록 설계되어 있습니다. 오직 block 요소들 사이에서만 발생하고 상하단의 margin만 병합이 일어납니다.
- 이를 방지하기 위해서는 부모 요소에 padding, border, overflow hidden 속성을 주거나 공간을 차지하는 요소나 텍스트를 사이에 넣습니다. 또는, 자식 요소에 display inline-block 속성을 줘도 방지할 수 있습니다.
