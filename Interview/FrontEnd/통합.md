## ⭐ 브라우저 렌더링 과정을 설명해주세요.

- 우선 사용자가 주소창에 무언가를 입력했을 때 브라우저 프로세스가 동작하며 URL인지 검색어인지 판단합니다. 검색어인 경우 검색 엔진이 작동하게 되고 URL인 경우 다운로드 파일 주소인지, 웹 사이트 주소인지를 판단하게 됩니다. 다운로드 파일인 경우 다운로드 매니저가 동작하고 웹 사이트 주소라면 HTML, PDF 파일 형식의 주소인 경우 랜더러 프로세스가 동작하게 됩니다. HTML 데이터를 수신해 HTML을 파싱하면서 DOM tree와 CSSOM Tree를 생성합니다. 이후 이를 합쳐 Render Tree를 생성하게 되고 이에 맞춰 레이아웃 과정과 페인트 과정을 거친 후 랜더링 준비가 완료되면 브라우저 프로세스에 요청을 보내게 되고 UI 스레드는 로딩표시를 멈추고 화면이 나타나게 됩니다.

## 브라우저는 어떻게 동작 하나요?

- 사용자가 참고하고자 하는 웹페이지를 서버에 요청하고 서버의 응답을 받아 브라우저에 표시하는 것이 브라우저의 핵심 동작 및 기능입니다.

## Webpack, Babel, Polyfill에 대해 설명해주세요.

- ## Webpack
- Babel
  - 모든 브라우저가 최신 자바스크립트 문법을 이해하고 있는 것이 아니기 때문에 브라우저가 이해할 수 있도록 변환해주는 장치
  - 파싱 -> 변환 -> 출력 단계로 빌드를 진행하면서 코드를 읽고 추상 구문트리로 변환하고 추상 구문트리를 변경하고 변경된 결과물을 출력합니다.
  - 바벨은 파싱과 출력을 담당하고 플러그인이 변환을 담당합니다.
  - 플러그인은 바벨이 어떤 코드를 어떻게 변환할지에 대한 규칙을 나타냅니다.
- Polyfill
  - 최신 ECMAScript 환경을 만들기 위해 코드가 실행되는 환경에 존재하지 않는 빌트인, 메소드 등을 추가하는 역할을 합니다. 바벨은 ES6+ 버전의 자바스크립트 코드를 ES5로 변환할 수 있는 것들만 변환하는데
  - 예를 들면 Promise와 같은 것들은 ES5 이전에 존재하지 않았고 변환할 수 있는게 없으므로 바벨만 사용하면 에러가 발생합니다. 이때 폴리필이 ES5 방식으로 구현해주어서 에러를 해결하게 해줍니다.

## ESLint와 Prettier에 대해 설명해주세요.

- ESLint
  - Javascript 코드에서 발견된 문제 패턴을 식별하기 위한 정적 코드 분석 도구.
  - 문법에 맞게 코드를 짤 수 있도록 도움말을 주는 기능을 합니다.
- Prettier
  - 단순히 정해진 규칙에 따라 코드 스타일을 자동으로 정리해주는 도구입니다.
  - 문법을 확인해주지 않습니다.

## SPA와 MPA에 대해 설명해주세요.

- SPA
  - Single Page Application으로 CSR 방식으로 렌더링 됩니다. 한 번만 리소스를 로딩하고 데이터를 받아올 때만 서버와 동신하게 됩니다. 페이지 이동 시 기존 페이지의 내부를 수정해서 보여주는 방식입니다.
  - 최초 페이지를 로딩한 시점부터 페이지 리로딩 없이 필요한 부분만 서버로부터 받아서 화면을 갱신하기 때문에 자연스러운 페이지 이동과 UX를 제공합니다. 성능면에서도 필요한 리소스만 부분적으로 로딩하므로 좋습니다. 서버의 템플릿 연산을 클라이언트로 분산하는 것이므로 또한 성능이 개선됩니다. 컴포넌트별 개발이 용이합니다.
  - SEO 관점에서 불리하다는 문제와 Javascript 파일을 번들링해서 한 번에 받기 때문에 초기 구동 속도가 느리다는 단점이 있습니다.(이는 Webpack의 code splitting으로 해결이 가능합니다.) 그리고 보안 이슈로 클라이언트 측에서는 쿠키 말고는 사용자 정보를 저장하기가 까다롭습니다.
  - 이 때 중요한 점은 SPA는 SSR, CSR 모두 가능합니다.
- MPA
  - Multiple Page Application으로 SSR 방식으로 렌더링 됩니다. 새로운 페이지를 요청할 때마다 서버에서 렌더링된 정적 리소스가 다운로드되고 페이지를 이동하거나 새로고침하면 전체 페이지를 다시 렌더링 하는 특징이 있습니다.
  - SEO 관점에서 유리하고 첫 로딩이 짧다는 장점이 있습니다.
  - 매번 새로운 페이지에서 깜빡이는 현상 즉 새로고침 현상이 발생해서 UX적으로 좋지 않습니다. 또한, 불필요한 템플릿도 중복해서 로딩하고 서버 렌더링에 따른 부하가 발생한다는 단점이 있습니다.

## ⭐ CSR과 SSR의 차이는 무엇인가요?

- CSR
  - 서버로부터 모든 파일(HTML, JS)을 불러와 클라이언트에서 페이지를 렌더링하고 보여주는 방식
  - 렌더링이 되는 동안 유저는 빈 화면만 볼 수 있습니다.
  - 다운이 완료된 JS가 실행되고 API 호출 및 응답이 완료되면 상호작용이 가능하게 됩니다.
  - 초기에 웹사이틑 렌더링 한 이후 페이지 이동이 빠르다는 장점과 자연스러운 UI/UX를 제공합니다.
  - 단점은 SEO 측면에서 좋지않고, 초기 로딩 시간이 많이 필요해 이동안 UX가 좋지 않습니다. 또한 HTML 파일이 하나이기에 각 페이지마다 다른 meta tag를 적용할 수 없습니다.
  - 즉 CSR은 네트워크가 빠르고 서버의 성능이 좋지 않거나 사용자에게 보여줘야 하는 데이터의 양이 많을 때 사용자와 상호작용하는 기능이 많을 때 사용하면 좋습니다.
- SSR
  - 서버 사이드 렌더링은 클라이언트가 서버로 요청을 보내면 서버에서 페이지를 렌더링 가능한 HTML 파일을 생성한 후 클라이언트에 전달한다.
  - 이미 렌더링 가능한 HTML이 왔으므로 사용자는 JS가 다운로드 되는 동안 화면에 컨텐츠를 볼 수 있지만 조작은 할 수 없습니다. 대신 이 때의 사용자 조작을 기억하고 있습니다.
  - 그렇게 JS까지 성공적으로 컴파일 되었다면 상호작용이 가능해지고 이전에 사용자의 조작을 실행하게 됩니다.
  - 장점은 모든 페이지가 각각 렌더링 되므로 페이지마다 다른 meta tag를 추가할 수 있습니다. 또한 SEO 관점에서 유리합니다.
  - 단점은 사용자가 많으면 서버에 부하를 많이 주게 되고 페이지 이동간 딜레이와 매번 렌더링을 해야하므로 자원이 많이 사용됩니다.
  - SSR은 네트워크가 느리고 SEO가 필요하며 최초 로딩이 빨라야 하고 웹사이트 상호작용이 크게 없을 때 사용하면 좋습니다.

## ⭐ CORS와 해결 경험을 말씀해주세요.

- Single Origin Policy
  - CSRF나 XSS를 예방하기 위한 정책으로 같은 출처의 리소스 공유만 허용하는 정책입니다.
  - 출처 비교와 차단은 브라우저가 합니다.
- Cross Origin Resource Sharing
  - 교차 출처 리소스 공유 정책으로 SOP의 문제를 해결하게 해주는 해결방안입니다.
  - 웹은 기본적으로 HTTP 프로토콜로 서버에 요청을 보내게 되는데, 브라우저는 요청 헤더에 Origin 이라는 필드에 출처를 함께 담아서 보내게 되고 서버는 응답헤더에 Access-Control-Allow-Origin을 담아 클라이언트로 전달하게 됩니다. 클라이언트에서는 서버에서 보내준 허용 출처와 자신이 보낸 출처를 비교해 유효한 경우 리소스를 가져오게 되고 유효하지 않다면 CORS 에러가 발생하게 됩니다.
  - 즉 근본적인 해결은 서버의 Access-Control-Allow-Origin 헤더를 세팅해 출처 허용이 필요합니다. 하지만 외에도 chrome 확장 프로그램 중 allow CORS 라는 확장프로그램을 설치해서 로컬 환경 API 테스트 시 CORS 문제를 해결하게 해줍니다. 혹은 프록시 사이트를 이용해서 해결하는 방법도 있습니다.

## bundle의 사이즈를 줄이려면 어떻게 해야 하나요?

-

## ⭐⭐ 쿠키, 세션, 웹스토리지의 차이에 대해 설명해주세요.

- 쿠키
  - 클라이언트에 저장되는 키와 같이 들어있는 작은 파일로 300개까지의 쿠키가 저장 가능하고 하나의 도메인당 20개의 값만 가질 수 있으며, 하나의 쿠키값은 4KB까지 저장이 가능합니다.
  - 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request 할 때 request header를 넣어서 자동으로 서버에 전송합니다.
  - 영속 쿠키(만료 날짜를 입력하면 해당 날짜까지 유지), 세션 쿠키(만료 날짜를 생략하면 브라우저 종료시까지만 유지)
- 세션
  - 사용자 정보를 파일 브라우저에 저장하는 쿠키와 달리 세션은 서버측에서 관리합니다.
  - 서버에서 클라이언트를 구분하기 위해 세션 ID를 부여하고 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지하게 됩니다.
  - 접속 시간에 제한을 두어서 일정 시간 응답이 없으면 정보가 유지되지 않게 설정할 수 있습니다.
  - 보안에는 좋지만 사용자가 많을수록 서버 메모리를 많이 차지하게 됩니다.
  - 쿠키와 세션 비교
    - 데이터 저장위치 : 쿠키는 클라이언트 세션은 서버
    - 보안 : 쿠키는 스니핑 위험, 세션은 쿠키를 이용해 세션 아이디만 젖장하고 서버에서 처리하므로 보안상 유리
    - 라이프 사이클 : 쿠키는 브라우저를 종료해도 만료기간이 남아있으면 존재하지만 세션은 브라우저 종료시 사라짐
    - 속도 : 쿠키가 세션보다 빠르다.
- 웹 스토리지(로컬/세션)
  - 클라이언트에 데이터를 저장할 수 있도록 HTML5부터 추가된 저장소. key-value 형태로 저장, 쿠키와 다르게 자동 전송의 위험성이 없고 origin 단위로 접근이 제한되므로 CSRF로부터 안전하고 쿠키보다 큰 저장 용량을 지원합니다. 오직 문자형 데이터 타입만 지원하기 때문에 객체형태로 저장하기 위해서는 Json stringify 와 파싱 과정이 필요.
  - 로컬
    - 사용자가 데이터를 지우지 않는 한 브라우저나 OS를 종료해도 계속 브라우저에 남아있는 영구성
    - 동일한 브라우저를 사용할 때만 해당됩니다.
    - 지속적으로 필요한 데이터 저장(자동로그인 여부 등)
  - 세션
    - 데이터가 오리진 뿐만 아니라 브라우저 탭에도 종속되므로 윈도우나 브라우저 탭을 닫을 경우 제거됩니다.
    - 일회성 데이터 저장(일회성 로그인, 입력폼 저장 등)

## 브라우저에서 탭 이동 혹은 탭 종료 시에는 세션 스토리지에 어떤 영향을 끼치나요?

-

## ⭐ 로그인 처리를 할 때 쿠키와 세션을 어떻게 사용하시나요?

- 일반적으로 쿠키를 사용합니다.

## ⭐ 토큰 기반 인증 방식에 대해 설명해주세요.

- 로그인을 하게 되면 서버에서 JWT 토큰을 보내주게 되고 이 JWT 토큰을 클라이언트가 이 인증 정보를 들고 있는 방식을 말합니다. 일반적으로 로컬 스토리지 혹은 쿠키에 저장되고 JWT의 경우 디지털 서명이 존재해 토큰의 내용이 위변조 되었는지 서버측에서 확인할 수 있습니다.

## ⭐ JWT 토큰을 쿠키에 저장했을 때 취약점에 대해 설명해주세요.

-

## ⭐ 크로스 브라우징에 대해 설명해주세요.

- Cross Browsing이란 적어도 표준 웹 기술을 채용하여 다른 기종 혹은 플랫폼에 따라 달리 구현되는 기술을 비슷하게 만듦과 동시에 어느 한쪽에 최적화되어 치우지지 않도록 공통 요소를 사용하여 웹페이지를 제작하는 기법

## 크로스 브라우징 이슈를 해결했던 경험을 말씀해주세요.

-

## 웹사이트 성능 최적화에는 어떤 방법이 있나요?

-

## 객체 지향 프로그래밍이란 무엇인가요?

-

## 객체 지향 프로그래밍의 특징에 대해 말씀해주세요.

-

## 객체 지향 프로그래밍의 장단점에 대해 말씀해주세요.

-

## ⭐ REST API에 대해 설명해주세요.

- 자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것을 의미합니다. HTTP URI를 통해 자원을 명시하고 HTTP Method를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미합니다.

## Git Flow에 대해 설명해주세요.

-

## ⭐ SEO에 대해 설명해주세요.

- SEO는 검색자 (검색 유저)의 의도를 이해하고 이에 충실히 맞춰 웹 페이지의 콘텐츠를 제작하는 과정입니다. 또한 웹 페이지가 검색 결과 페이지에서 잘 노출 되도록 페이지의 태그와 링크 구조를 개선하여 자연 유입 트래픽을 늘리는 방법론으로도 정의할 수 있습니다.

## BOM과 DOM에 대해 설명해주세요.

-

## ⭐ 리플로우와 리페인트에 대해 설명해주세요.

- 윈도우 리사이징, 폰트의 변화, 스타일 추가 또는 제거, 내용 변화, JS로 인한 DOM의 동적인 변화 등이 일어나는 경우 웹사이트의 내용을 그에 적용한 상태로 보여주기 위해 새롭게 렌더트리를 바탕으로 레이아웃과 페인트 및 합성과정을 거치게 되는 것을 말합니다.

## 리플로우와 리페인트의 발생 조건에 대해 설명해주세요.

-

## visibility 속성은 리플로우를 발생시킬까요?

-

## Agile에 대해 설명해주세요.

-

## dependencies 와 devDependencies 차이에 대해 설명해주세요.

-

## XSS와 CSRF에 대해 설명해주세요.

- XSS
  - 일반적으로 자바스크립트에 악성 코드를 삽입해서 해당 서비스에 의도치 않은 행동을 수행시키거나 쿠키나 세션을 탈취하는 행위를 말합니다.
- CSRF
  - 서버 요청에 권한을 도용해 가짜 요청을 서버에 전송하는 경우를 말합니다.

## 인증과 인가에 대해 설명해주세요.

-

## package.json에서 private에 대해 설명해주세요.

-

## 프로젝트를 npm에 배포하려면 어떤 설정이 필요할까요?

-

## ⭐ SEO는 어떤 식으로 신경쓰셨나요?

-

## ⭐ 어플리케이션의 성능은 어떤식으로 측정하셨나요?

-

## LightHouse 결과가 좋지 않을 때, 프로젝트에서 병목 현상은 어떻게 해결할 수 있을까요?

-

## ⭐ 주소창에 주소를 입력했을 때의 흐름을 설명해주세요.

-
