## React에 대해 설명해주세요.

- 자바스크립트 라이브러리입니다. 싱글 페이지 어플리케이션을 개발하는데 최적화 되어 있고 기존의 자바스크립트가 가지고 있던 직접적인 DOM을 조작해 모든 UI를 새롭게 갱신하는 방법을 개선해 동적으로 UI를 갱신할 수 있도록 할 수 있는 문제를 해결한 라이브러리입니다.

## React의 원리, 특징, 장단점이 무엇인가요?

### 원리

- virtual DOM을 사용하여 UI를 빠르게 랜더링 한다. virtual DOM은 이전 UI 상태를 메모리에 유지해서 변경될 UI 최소 집합을 계산하는 로직을 포함하고 있는데 이로써 좋은 성능을 낸다. 단방향 데이터 흐름으로 작동한다.

### 특징

- component(클래스형, 함수형) 기반으로 이루어져 있다.
- virtual DOM(가상돔) 기반으로 가볍다.
- component는 state와 props를 가진다.
  - state : 컴포넌트 내부에서 값을 저장하거나 변경할 수 있는 데이터, 동적인 데이터(변경 가능), Component 안에서 관리
  - props : 부모 컴포넌트에서 자식 컴포넌트로 전달해주는 데이터, 읽기 전용 데이터(변경 불가능, but set함수를 전달할 경우 수정 가능), Component에 전달
- 단방향 데이터 바인딩(부모 -> 자식 컴포넌트로 전달하는 데이터 흐름)
  - 장점 : 데이터 변화가 일어났을 때 성능저하 없이 DOM 객체 갱신 가능, 데이터 추적과 디버깅 용이
  - 단점 : 데이터 변화에 따른 화면 업데이트 코드를 매번 작성해주어야 한다.

### 장단점

- 장점

  - 방대한 커뮤니티와 문서 가이드가 상세하고 자료가 많다.
  - MVC, MVVM 패턴처럼 로직을 분리하는 것이 아니라 Component 하나로 관리할 수 있다(view)
  - 성능이 뛰어난 가비지 컬랙터 기능을 지원한다.
  - UI 수정과 재사용성이 좋고 코드 가독성이 좋다.
  - 다른 framework나 라이브러리와 혼용이 쉽다.(확장성이 좋다.)

- 단점
  - IE8 이하 버전은 지원하지 않는다.
  - view 이외의 기능은 직접 구현하거나 라이브러리를 사용해야 하므로 JS 배경지식이 필요하다.
  - 데이터 모델링, 라우팅, AJAX 등 기능 지원이 안되므로 라이브러리를 활용해야 한다.
  - 로딩시간이 길다.
  - 웹의 궁극적 지향점과는 다소 동떨어져있다.
    - 웹의 핵심 : 모든 것을 streaming 하고, 페이지들은 HTML 태그들을 내포하고 가벼운 response만 브라우징한다.
    - 리액트 : 사이트에 필요한 JS를 처음에는 공백 페이지를 띄우면서 다운로드 한다. 한번 다운로드 한 이후에는 다시 리소스를 다운하지 않아도 되지만, 처음 보이는 것이 없다는 것이 streaming과의 차이.

## Virtual DOM 이 무엇인지 설명해주세요.

### DOM이란?

- 문서 객체 모델이라고 하며, 브라우저에서 다룰 HTML 문서를 파싱해 문서의 구성요소들을 객체로 구조화해 나타낸 것입니다.

### Virtual DOM이란?

- DOM을 추상화한 가상의 객체라고 표현할 수 있습니다. SPA의 특징으로 DOM의 복잡도가 증가하고 최적화와 유지보수의 어려움이 생기고 있고 DOM을 반복적으로 직접 조작하면 그만큼 브라우저가 랜더링을 빈번하게 해야 되므로 자원 소모가 커진다는 문제를 해결하기 위해 등장했습니다.

### 작동원리

- DOM을 추상화한 가상의 객체를 메모리에 만들어 놓고 변경내역을 한번에 모은다음 실제 DOM과 비교해 변경된 Virtual DOM과의 차이를 판단한 후에 구성요소의 변경이 일어난 부분만 찾아서 변경하고 그에 따른 렌더링을 한 번만 하는 방식으로 동작합니다. 예를들어 ul태그 안에 li태그가 10개씩 들어가서 리스트를 보여주는 UI가 있다고 가정했을 때 다음페이지를 누르게 되면 기존에는 li태그 10개를 10번의 수정을 통해 UI를 랜더링 했다고 하면 virtual dom은 변경사항을 모두 저장한다음 변경된 li태그 10개를 ul태그 하나만 변경해서 랜더링 1번으로 UI를 갱신할 수 있게 됩니다.
-

## Virtual DOM 작동 원리에 대해 설명해주세요.

- UI가 변경되면 전체 UI를 Virtual DOM으로 랜더링 한다. 현재 VD와 이전 VD를 비교해 차이를 계산한다. 변경된 부분을 실제 DOM에 반영한다.

## ⭐ JSX에 대해 설명해주세요.

- Javascript에 XML을 추가한 확장문법입니다. 리액트로 개발할 때 사용되기 때문에 공식적인 자바스크립트 문법은 아닙니다. 브라우저에서 실행하기 전에 바벨을 사용해서 일반 자바스크립트 형태의 코드로 변환됩니다. 장점으로는 가독성과 코드의 효율성을 가져갈 수 있다는 점입니다.

## 엘리먼트와 컴포넌트의 차이에 대해 설명해주세요.

- 엘리먼트
  - React 앱의 가장 작은 단위로 화면에 표시할 내용을 기술할 수 있는 것. React의 엘리먼트는 일반 객체로 쉽게 생성할 수 있고 React DOM은 React 엘리먼트와 일치하도록 DOM을 업데이트해준다. 즉 엘리먼트는 컴포넌트의 구성요소. 인스턴스는 아니다.
- 컴포넌트
  - 함수 컴포넌트는 데이터를 가진 props 객체인자를 받아 element를 반환한다. UI를 재사용 가능한 개별적인 여러 조각으로 나눈 것 중 하나. 컴포넌트는 앨리먼트 트리를 캡슐화한다.

## 리액트에서 컴포넌트를 어떻게 생성하나요?

- src 폴더 안에 파일을 생성하고 REACTDOM.Render

## 클래스형 컴포넌트를 사용해보셨나요?

-

## ⭐ 클래스형 컴포넌트와 함수형 컴포넌트의 차이에 대해 설명해주세요.

- 클래스형 컴포넌트

  - class라는 키워드가 필요하고 Component로 상속을 받아야하고 render()메소드가 반드시 있어야 합니다.
  - state, lifeCycle 관련 기능 사용이 가능하고, 메모리 자원을 함수형 컴포넌트보다 조금 더 사용하고 임의 메서드를 정의할 수 있습니다.
  - constructor 안에서 this.state 초기값을 설정하거나 constructor 없이 바로 state 초기값을 설정할 수 있습니다. 그리고 state는 객체 형태이고 this.setState 함수로 state의 값을 변경할 수 있습니다.
  - props는 this.props로 값을 불러올 수 있고 부모 객체의 키 값과 자식 props 활용합니다.
  - 이벤트 핸들링의 경우 요소에서 적용하기 위해서는 this를 작성해주어야 합니다. 화살표 함수로 함수 선언 가능.

- 함수형 컴포넌트
  - 기존에는 못하던 것들을 hook을 통해 할 수 있게 되면서 확실히 코드의 효율성이 올라갔다.
  - state, lifeCycle관련 기능사용은 불가능하지만(기존), hook을 통해 해결 가능합니다(현재). 메모리 자원을 상대적으로 덜 사용하고 컴포넌트 선언이 편리합니다.
  - useState로 state 값을 사용하거나 수정합니다. 첫번째 배열의 값은 현재 상태, 두번째 원소는 상태를 바꾸어주는 함수입니다.
  - 따로 props를 불러올 필요 없이 바로 호출해서 사용할 수 있습니다.
  - 이벤트 핸들링은 const 키워드 + 함수 형태로 선언 해야합니다. 요소에 적용할 때 this는 필요없다.

## ⭐ 라이프사이클에 대해 설명해주세요.

- 기본적으로 mount -> update -> unmount 생명주기를 갖는다. 리액트의 클래스 컴포넌트는 라이프 사이클 메서드를 사용하고, 함수형 컴포넌트는 hook을 사용합니다.

## ⭐ 라이프 사이클 메소드에 대해 설명해주세요.

### 생성

- constructor : 생성자로 초기 상태값을 정할 수 있습니다. 클래스에서는 constructor을 사용하고 함수형 컴포넌트에서는 useState를 사용하면 쉽게 초기 상태를 정할 수 있습니다.
- getDerivedStateFromProps : props로부터 파생된 state를 가져옵니다. 즉 props 받아온 것을 state에 넣어주고 싶을 때 사용합니다.
- render : 가장 기초적인 메서드이면서 중요한 메서드입니다. 컴포넌트를 렌더링할 때 필요한 메서드이면서 유일한 필수 메서드입니다.
- componentDidMount : 첫번째 렌더링이 끝나고 호출되는 메서드입니다. 이 메서드가 호출되는 시점에는 화면에 컴포넌트가 나타난 상태입니다.

### 업데이트

- getDerivedStateFromProps : props로부터 파생된 state를 가져옵니다. 즉 props 받아온 것을 state에 넣어주고 싶을 때 사용합니다.
- shouldComponentUpdate : props나 state를 변경했을 때, 리렌더링 여부에 대해 결정하는 메서드입니다.
- render : 가장 기초적인 메서드이면서 중요한 메서드입니다. 컴포넌트를 렌더링할 때 필요한 메서드이면서 유일한 필수 메서드입니다.
- getSnapshotBeforeUpdate : render에서 만들어진 결과가 브라우저에 실제로 반영되기 직전에 호출됩니다. 흔히 사용하지는 않지만, 채팅 화면처럼 스크롤 위치를 따로 처리할 때 필요합니다.
- componentDidUpdate : 리렌더링이 마치고, 화면에 우리가 원하는 변화가 모두 반영되고 난 뒤 호출되는 메서드입니다. 3번째 파라미터로 getSnapshotBeforeUpdate 에서 반환한 값을 조회 할 수 있습니다.

### 제거

- componentWillUnmount : 컴포넌트가 화면에서 사라지기 직전에 호출됩니다. DOM에 등록했던 이벤트를 제거하고 setTimeout과 같은 것들을 clear 해줍니다.

## ⭐ 함수형 컴포넌트의 장점에 대해 설명해주세요.

- 메모리 자원을 상대적으로 덜 사용하고 컴포넌트 선언이 편리합니다. 기존의 class형 컴포넌트의 가장 큰 문제 중 하나는 this는 mutable 하기 때문에 예기치 못한 결과나 에러가 발생할 수 있었습니다. 이러한 불변성을 유지하고, props에 따른 랜더링 결과를 보장받는다는 장점이 있습니다. 그리고 가독성이 좋아진다는 장점도 있습니다.

## ⭐ React Hooks에 대해 설명해주세요.

- 함수형 컴포넌트에서 React state와 생명주기 기능을 연동할 수 있게 해주는 함수입니다.
- 라이프사이클 메서드 기반이 아닌 로직을 기반으로 컴포넌트를 함수 단위로 잘게 쪼갤 수 있다는 장점이 있습니다.
- 라이프 사이클 메서드에는 관련 없는 로직이 섞여 들어가는 경우가 많은데, 무결성을 해치는 문제를 해결했습니다.
- 최상위에서만 Hook을 호출해야 하고 함수형 컴포넌트에서만 Hook을 호출해야 한다는 규칙이 있습니다.

## ⭐ 함수형 컴포넌트에서 클래스형 컴포넌트의 라이프 사이클 메소드를 비슷하게 사용하는

- useState : 상태를 관리합니다.
- useEffect : 화면에 렌더링이 완료된 이후에 수행되며 componentDidMount, componentDidUpdate, componentWillUnmount가 합쳐진 것입니다. useEffect 안에 의존성 배열이 없는 경우에는 렌더링 결과가 실제 돔에 반영된 순간마다 호출되고, 의존성 배열을 비워둔채로 두면 컴포넌트가 처음 나타날때 한 번 호출하게 되고, 의존성 배열안에 값을 넣게 되면 조건부로 의존성 중 하나가 변경될 때마다 내부 로직이 실행되게 됩니다.
- 방법에 대해 설명해주세요. (useEffect => ComponentDidMount, ComponentDidUpdate, ComponentWillUnmount)

## useEffect와 useLayoutEffect의 차이점에 대해 설명해주세요.

- useEffect는 렌더링이 완료된 후에 수행된다면 화면이 모두 렌더링 되기 전에 동기화 시켜야할 로직이 필요한 경우에는 useLayoutEffect를 사용해서 컴포넌트 렌더링 - useLayoutEffect - 화면 업데이트 순으로 실행시킬 수 있습니다.

## Pure Component에 대해 설명해주세요.

- props랑 state를 얕은 비교(변수와 문자열에서는 값을 비교한다, object에서는 reference값을 비교한다)를 통해 비교한 뒤 변경된 것이 있을때는 true를 return 해서 리렌더링 하고, 변경된 것이 없을때는 false를 리턴한다. 즉, shouldComponentUpdate가 상태값에 따라서 적절하게 동작할 수 있도록 한다. 성능 향상에 도움이 된다.

## shouldComponentUpdate에 대해 설명해주세요.

- shouldComponentUpdate : props나 state를 변경했을 때, 리렌더링 여부에 대해 결정하는 메서드입니다. 기본값은 true인데 false를 반환할 경우 render()와 componentDidUpdate()는 호출되지 않습니다.

## State에 대해 설명해주세요.

-

## React에서 State를 어떻게 관리하나요?

- 불변성을 원칙으로 deep copy를 통한 state 관리를 진행합니다. 하나의 객체나 값을 변경하게 되면 이를 참조하는 객체의 값도 변동되는 문제를 deep copy로 독립된 상수로 지정해서 해당 값만 변경될 수 있도록 관리하는 것입니다.

## Props에 대해 설명해주세요.

- 부모 -> 자식에게 전달되는 데이터, 읽기 전용.

## ⭐ Props Drilling에 대해 설명해주세요.

- 너무 높은 조상 컴포넌트에서 하위 컴포넌트로 데이터를 전달해야되는 문제. 10번을 Props 해줘야할수도 있다.

## ⭐ Props Drilling을 어떻게 해결할 수 있나요?

- 전역 상태관리로 해결할 수 있습니다.

## 데이터를 자식에서 부모로도 전달할 수 있나요?

- 단방향 데이터 흐름을 가지고 있기 때문에 데이터를 직접 전달하는 것은 안됩니다. 하지만 setter함수를 props로 넘겨주어 이벤트에 맞게 값이 변경될 수 있도록 할 수 있습니다.

## Props와 State의 차이에 대해 설명해주세요.

-

## 왜 state를 직접 바꾸지 않고 setState (useState)를 사용해야 하나요?

- React 가 state의 변경을 감지하는 방식때문에 setState를 사용해야 합니다. 불변성을 유지하지 않은채로 state를 변경할때는 state의 변경을 감지하지 못하기 때문에 화면이 리렌더링 되지 않습니다. 그러므로 불변성을 유지하면서 값을 변경해주는 setState를 사용해야 합니다.

## React 에서 상태 변화가 생겼을 때, 변화를 어떻게 알아채는지에 대해 설명해주세요.

-

## React에서 State의 불변성은 어떻게 유지할 수 있나요?

- React의 상태를 업데이트하는 원리 때문에 불변성을 유지해야 합니다. 리액트는 상태값을 업데이트 할 때 얕은 비교를 수행하게 되는데, 이 말은 즉슨 객체의 속성 하나하나를 비교하는게 아니라 참조값만 비교하여 상태 변화를 감지하기 때문에, 객체나 배열의 속성이나 값을 바꾸는 불변성이 없는 변경은 상태가 바뀌었다고 파악하지 못하기 때문에 불변성을 지키는 업데이트가 필요합니다. 또한 사이드 이펙트를 방지할 수 있습니다.
- 불변성을 지키지 않으면 값이 변화했다는 사실을 React가 모르기 때문에 리렌더링이 되지 않습니다. 그래서 spread 연산자나 map, filter, slice, reduce 등의 메서드 처럼 새로운 배열을 반환하는 메서드들이 존재하고 이를 활용하면 불변성을 유지할 수 있습니다.

## setState는 동기적으로 동작하나요? 아니면 비동기적으로 동작하나요?

- 비동기적으로 동작합니다.

## 왜 비동기적으로 동작하나요?

- 변경이 하나라면 리렌더링이 한번만 이뤄지면 되지만, 수십, 수백개의 값이 계속 변경된다면 리액트는 매번 리렌더링만 하게 될 것입니다. 속도는 현저히 저할될 거구요. 따라서 변경된 값들을 모아 한번에 업데이트를 진행하여 렌더링을 줄이고자 배치(Batch)기능을 사용해서 비동기로 동작합니다. 배치 업데이트 주기는 16ms입니다.

## HTML과 React의 이벤트 처리 차이점에 대해 설명해주세요.

- HTML에서 속성의 이름은 모두 lowercase이고 어딘가 정의된 함수를 string형태로 전달받습니다. form처럼 element에 정의된 기본 동작을 막기 위해서는 return false를 통해서 막을 수 있습니다.
- React에서 속성의 이름은 camelCase이고, {}(bracket) 형태로 함수를 전달받습니다. form처럼 element에 정의된 기본 동작을 막기 위해서는 e.preventDefault()를 호출해야 합니다.

## ⭐ Key Props를 사용하는 이유에 대해 설명해주세요.

- element의 안정적인 고유성을 부여하기 위해서 내부의 엘리먼트에 지정해주는 것을 key라고 합니다. 다른 항목들 사이에서 고유하게 해당 element를 식별하고 이에 대해 접근하기 위해서 필요합니다.

## Ref의 용도에 대해 설명해주세요.

- render 메서드에서 생성된 DOM 노드나 React 엘리먼트에 접근할 수 있는 방법을 제공하는 것입니다. 포커스, 텍스트 선택 영역, 미디어 재생 관리, 애니메이션 실행 여부 판단, 서드파티 DOM 라이브러리를 React와 같이 사용할 떄 필요합니다.

## ⭐ 제어 컴포넌트와 비제어 컴포넌트의 차이에 대해 설명해주세요.

- 제어 컴포넌트
  - 사용자의 입력을 기반으로 자신의 state를 관리하고 업데이트 하는 컴포넌트. React 컴포넌트에서 폼 데이터를 다룸
  - 변경할 수 있는 state가 일반적으로 컴포넌트의 state 속성에 유지되며 setState()에 의해 업데이트 됩니다.
  - React에 의해 값이 제어되는 입력 폼 엘리먼트를 제어컴포넌트라고 합니다. 즉 입력을 받는 컴포넌트에 event 객체를 이용해 setState()로 값을 저장하는 방식을 제어 컴포넌트 방식이라고 할 수 있습니다.
  - 유효성검사, 조건에 따른 버튼 활성화 여부(유효한 데이터가 없는 경우 전송 버튼 disabled로 만들기), 신용카드와 같은 특정 입력 방식 적용하기(실시간 필드 검사).
  - 매 입력마다 리렌더링과 동기화가 되기 때문에 불필요한 리렌더링과 불필요한 API 요청이 이루어질 수 있기 때문에 자원낭비를 막기 위해 스로틀링(마지막 함수가 호출된 후 일정시간이 지나기 전에 다시 호출되지 않도록 하는 것)이나 디바운싱(연이어 호출되는 함수들 중 마지막 또는 첫 함수만 호출하도록 하는 것)을 적용한다.
- 비제어 컴포넌트
  - React에 의해서 값이 제어되지 않는 컴포넌트. 기존의 바닐라 JS와 크게 다르지 않은 방식으로 setState()를 쓰지 않고 ref를 사용해 값을 얻어와서 활용합니다. 그렇기 때문에 값이 실시간으로 동기화되지 않아 변화를 즉각적으로 대응할 수 없습니다. 사용자가 직접 트리거를 작동시키기 전까지 리렌더링과 동기화가 되지 않습니다. DOM 자체에서 폼 데이터를 다룸

## HOC (Higher-Order Components)에 대해 설명해주세요.

- React 구성적 특성에서 나오는 패턴. 컴포넌트를 가져와서 새 컴포넌트를 반환하는 함수입니다. redux의 connect와 relay의 createFragmentContainer와 같은 서드 파티 React 라이브러리에서 흔하게 볼 수 있습니다.

## Context API에 대해 설명해주세요.

- 일반적으로는 부모와 자식컴포넌트간에 props를 통해 state를 변화시키는데 반해, context api는 이러한 경계 없이 컴포넌트 트리 전체에 데이터를 제공할 수 있도록 해줍니다. 즉, 전역적으로 데이터를 공유해야 하는 상황에 사용합니다.
- createContext로 컨텍스트를 생성한 다음 Provider로 데이터를 전달해야될 컴포넌트를 감싸줍니다. 그리고 사용할 때는 Consumer로 context의 변화를 구독하는 컴포넌트를 생성합니다. 이때의 context 값은 가장 가까운 provider 값이고 provider이 없으면 createContext할때 넣어준 defaultValue를 가집니다.

## React.Fragment에 대해 설명해주세요.

- React에서 컴포넌트가 여러 엘리먼트를 반환하는 것은 흔한 패턴인데 그럴 때마다 의미 없는 div로 여러 엘리먼트를 묶지 않고 Fragments를 사용해서 DOM에 별도의 노드를 추가하지 않고도 여러 엘리먼트를 그룹화할 수 있도록 하는 것입니다.
- <></> 흔히 말하는 코스트태그 단축문법을 사용할 수 있지만, Fragment 는 key 또는 어트리뷰트를 지원하고 고스트 태그는 지원하지 않기 때문에 key props를 해야한다면, Fragment 사용.

## Portal에 대해 설명해주세요.

- 부모 컴포넌트의 DOM 계층 구조 바깥에 있는 DOM 노드로 자식을 렌더링하는 최고의 방법입니다. 즉 외부에 존재하는 DOM 노드가 React App DOM 계층 안에 존재하는 것처럼 연결해주는 포탈 기능을 제공합니다.
- 일반적으로 컴포넌트 렌더링 메서드에서 엘리먼트를 반환할 때 엘리먼트는 부모 노드에서 가장 가까운 자식으로 DOM에 마운트 되는데, DOM의 다른위치에 자식을 삽입하는 것이 유용한 상황이 있습니다. 부모 컴포넌트에 overflow:hidden이나 z-index가 있는 경우, 다이얼로그나 호버카드 툴팁과 같은 자식이 튀어나오도록 보여야 하는 경우에 사용하기 좋습니다.
-

## 에러 바운더리에 대해 설명해주세요.

-

## 메모이제이션에 대해 설명해주세요.

- 기존에 수행한 연산의 결과값을 저장해두고 동일한 입력이 들어올때 재활용하는 프로그래밍 기법

## ⭐ 리액트에서 메모이제이션을 어떤 방식으로 활용할 수 있나요?

- useMemo, useCallback과 같은 훅으로 공통적으로 자주 사용되는 값이나 함수를 저장해두고 만약 변경된 로직이 적용되어야 할 때 변경해서 사용할 수 있도록 저장해서 사용이 가능합니다.

## ⭐ useMemo와 useCallback에 대해 설명해주세요.

### useMemo

- 어떤 값이 연산을 통해서 정해진다면, 렌더링 될 때마다 다시 연산이 되면 자원이 낭비됩니다. 이를 해결 하기 위해서 연산된 값이 변경되지 않는다면, 이러한 값을 저장해두고 새로운 연산없이 바로 사용할 수 있도록 저장해두고 사용할 수 있는 값을 반환하는 hook입니다.

### useCallback

- 콜백함수를 저장해서 의존성에 의해 변경이 있을 때만 새로운 콜백함수로 저장해서 다시 재사용할 수 있게 합니다.

## React.memo와 useMemo의 차이에 대해 설명해주세요.

- React.memo는 HOC(컴포넌트를 인자로 받아서 새로운 컴포넌트를 return해주는 함수)입니다. 만약 같은 props를 받을 때 같은 결과를 렌더링 한다면 react.memo를 사용해 불필요한 컴포넌트 렌더링을 방지할 수 있습니다. 오직 props의 변경 유무만 확인하고 변경됐다면 새로운 컴포넌트를 생성해 렌더링합니다. 비교함수를 두번째 인자로 넣을 수 있습니다.
- 차이점은 HOC는 클래스형, 함수형에 모두 사용가능하지만, useMemo는 함수형 컴포넌트에서만 사용이 가능합니다.

## 리액트 관련 패키지 중에 제일 좋다고 생각한 것은 무엇인가요?

-

## 리액트의 렌더링 성능 향상을 위해 어떻게 해야 하나요?

- 함수형 컴포넌트 사용. pure component 사용

## CSS in JS를 사용해 본 적이 있나요? 있다면 소감을 말해주세요.

-

## React 18 버전 업데이트 내용에 대해 말씀해주세요.

-

## Client Side Routing에 대해 설명해주세요.

-

## Next.js 를 사용해보셨나요?

-

## React에서 Form 이벤트는 어떻게 제어하셨나요?

-

## React Hook Form 를 사용해보셨나요?

-

## 기억나는 Hook에 대해 전부 설명해주세요.

-

## React에서 컴포넌트 A가 사용하는 CSS파일과 컴포넌트 B가 사용하는 CSS파일의 선택자가 겹치는 이유가 뭘까요?

-

## ⭐ Redux에 대해 설명해주세요.

- 자바스크립트 상태관리 라이브러리. Node.js 모듈입니다. Redux의 기본 개념 중 세가지 원칙이 있습니다.

  - Single source of truth
    - 동일한 데이터는 항상 같은 곳에서 가지고 온다는 뜻으로, 스토어라는 하나뿐인 데이터 공간만 존재해야 합니다.
  - State is read-only
    - 리액트에선 setState 메소드로만 상태 변경이 가능합니다. 리덕스도 마찬가지로 액션이라는 객체를 통해서만 상태를 변경할 수 있습니다.
  - Changes are made with pure functions
    - 변경은 순수함수로만 가능하며, 리듀서와 연관되는 개념이라고 볼 수 있습니다. store-action-reducer

- Store & Action & Reducer
  - Store
    - 상태가 관리되는 오직 하나의 공간
    - 컴포넌트와는 별개로 스토어라는 공간이 존재해서 그 스토어 안에 앱에서 필요한 상태를 담는다.
    - 컴포넌트에서 상태정보가 필요할 때 스토어에 접근한다.
  - Action
    - 앱에서 스토어에 운반할 데이터를 말한다(주문서)
    - 자바스크립트 객체 형식으로 되어 있다.
    ```
    {
      type: 'ACTION_CHANGE_USER', // 필수
      payload: { // 옵션
      name: '하나몬',
      age: 100
      }
    }
    ```
  - Reducer
    - 액션을 스토어에 바로 전달하는 것이 아니라 액션을 리듀서에게 전달하고 리듀서가 이 액션 주문서를 보고 스토어의 상태를 업데이트 하는 것이다. 액션을 리듀서에게 전달하기 위해서는 dispatch가 필요하다.
  - 즉 정리하면, Action 객체가 dispatch() 메소드에 전달되고 dispatch(액션)을 통해 reducer가 호출되고 reducer는 새로운 store을 생성한다고 보면된다. 이 모든 것들은 단방향 데이터 흐름을 유지하기 위한 로직.

## ⭐ Redux를 사용하는 이유에 대해 설명해주세요.

- 순수함수를 사용하기 때문에 상태를 예측할 수 있고 유지보수하기 편리하며 redux dev tool을 제공하기에 디버깅에 유리합니다. 테스트를 하기 편하다는 장점이 있습니다.

## ⭐ Redux의 장단점에 대해 설명해주세요.

- 장점
  - 단방향 모델링(한가지 방향으로만 바뀐다)임. action을 dispatch 할때마다 기록(history)이 남아 에러를 찾기 쉽다. 타임머신 기능을 사용할 수 있음
  - 상태의 중앙화 : 스토어(Store)라는 이름의 전역 자바스크립트 변수를 통해 상태를 한 곳에서 관리하는데, 이를 중앙화라 함. 전역 상태를 관리할때 굉장히 효과적
  - Redux는 상태를 읽기 전용으로 취급한다. 상태가 읽기 전용이므로, 이전 상태로 돌아가기 위해서는 그저 이전 상태를 현재 상태에 덮어쓰기만 하면 됨. 이런 식으로 실행 취소 기능을 구현.
- 단점
  - 아주 작은 기능이여도 리덕스로 구현하는 순간 몇 개의 파일(액션등을 미리 만들어놔야함)들을 필수로 만들어야하여 코드량이 늘어난다.
  - 타임머신 기능을 사용하려면 불변성 개념을 지켜야 사용할 수 있으므로 매번 state라는 객체를 만들어줘야 함
  - Redux는 상태를 읽기 전용으로 취급할 뿐, 실제 읽기 전용으로 만들어주지는 않습니다. 때문에 상태를 실수로 직접 변경하지 않도록 항상 주의해야 합니다. 이를 예방하기 위해 Immutable.js같은 라이브러리도 존재합니다.
  - 다른 것 다 필요 없고 상태 관리를 중앙화하는 것만 있어도 된다면 Context API 를 사용

## Flux 패턴에 대해 설명해주세요.

- 단방향 흐름 데이터.

## Context API와 Redux를 비교해주세요.

- Context API
  - React에서만 사용할 수 있습니다. (리액트 내장 기능)
  - Entry 파일(root)에서 구성한 Provider를 내려 주는 형식입니다.
  - 사용하고자 하는 컴포넌트에서 작성한 Dispatch와 State를 꺼내서 사용합니다.
  - reducer를 여러 개 만들면 Provider에서 여러 단계로 만들어 사용할 수 있습니다.
  - Action, reducer, provider
- Redux
  - React, Vue와 같은 프레임워크 환경에서 사용할 수 있습니다.
  - 상태를 저장하는 Store를 따로 가지고 있습니다.
  - thunk, saga와 같은 미들웨어를 추가적으로 사용하여 구성할 수 있습니다.
  - Redux devtool extension을 사용하면 상태에 대한 디버깅이 가능합니다.
  - 전역 상태 관리 외에도 로컬스토리지 상태저장, 버그리포트 첨부 기능 등의 기능들을 사용할 수 있습니다.
  - Store, Action, Reducer, Dispatch

## Redux의 3대 원칙에 대해 설명해주세요.

- Single source of truth
  - 동일한 데이터는 항상 같은 곳에서 가지고 온다는 뜻으로, 스토어라는 하나뿐인 데이터 공간만 존재해야 합니다.
- State is read-only
  - 리액트에선 setState 메소드로만 상태 변경이 가능합니다. 리덕스도 마찬가지로 액션이라는 객체를 통해서만 상태를 변경할 수 있습니다.
- Changes are made with pure functions
  - 변경은 순수함수로만 가능하며, 리듀서와 연관되는 개념이라고 볼 수 있습니다. store-action-reducer

## React-Query를 사용해보셨나요?

-

## React-Query에 대해 설명해주세요.

- 서버의 값을 클라이언트에 가져오거나, 캐싱과 값 업데이터 그리고 에러핸들링 등 비동기 과정을 더욱 편하게 하는데 사용하는 라이브러리 입니다.

## React-Query의 등장 배경과 장점에 대해 설명해주세요.

- 서버로 부터 값을 가져오거나 업데이트 하는 로직을 store 내부에 개발하는 경우가 많습니다. 그렇다보니 store는 클라이언트 state를 유지해야하는데 어느 순간부터 store에 클라이언트 데이터와 서버 데이터가 공존 하게 됩니다. 그리고 그 데이터가 서로 상호작용하면서 서버 데이터도 클라이언트 데이터도 아닌 끔찍한 혼종(?)이 탄생하게 됩니다. (예를 들면 서버에는 이미 패치된 데이터가 클라이언트에서는 패치되기 전 데이터가 유저에게 사용되고 있는 것이라고 볼 수 있습니다.) 그래서 react-query를 사용함으로 서버, 클라이언트 데이터를 분리합니다. 이 개념에 대해 동의 하지 않아도 아래의 장점을 보신다면 사용하고 싶은 생각이 드실 것입니다.
- 장점
  - 캐싱
  - get을 한 데이터에 대해 update를 하면 자동으로 get을 다시 수행한다. (예를 들면 게시판의 글을 가져왔을 때 게시판의 글을 생성하면 게시판 글을 get하는 api를 자동으로 실행 )
  - 데이터가 오래 되었다고 판단되면 다시 get (invalidateQueries)
  - 동일 데이터 여러번 요청하면 한번만 요청한다. (옵션에 따라 중복 호출 허용 시간 조절 가능)
  - 무한 스크롤 (Infinite Queries (opens new window))
  - 비동기 과정을 선언적으로 관리할 수 있다.
  - react hook과 사용하는 구조가 비슷하다.

## Recoil을 사용해보셨나요?

-re

## Recoil에 대해 설명해주세요.

-

## Recoil에서 Loadable의 개념에 대해 설명해주세요.

- recoil에서 비동기 처리를 할때는 두 가지 방법이 있습니다. suspense로 컴포넌트를 감싸서 비동기 상태에 대한 처리를 진행해주거나 Loadable을 적용할 수 있습니다.
  - suspense : 컴포넌트가 렌더링되기 전까지 기다리게 해주는 것
- 비동기 통신을 위해 recoil에서 제공하는 비동기 제어 방법으로 useRecoilValueLoadable과 useRecoilStateLoadable 두가지를 지원합니다. Loadable 안의 state는 hasValue, loading, hasError 3가지 상태가 존재하며 contents라는 비동기 통신의 결과값으로 나뉘어집니다.

## Recoil에서 비동기로 데이터를 받아올 때 State를 어떻게 관리하셨나요?

-

## Recoil에서 로딩, 성공, 에러와 관련된 처리를 어떻게 하셨나요?

-

## ⭐ Redux와 Recoil에 대해 비교 설명해주세요. (개념, 장단점)

### Recoil

- context API 기반 함수형 컴포넌트에서만 사용 가능. 배우기 쉽고 내장된 Hooks와 사용법이 유사하다는 장점이 있습니다. redux와 다르게 비동기 처리를 기반으로 하기 때문에 동시성 모드를 제공해 비동기 처리 라이브러리를 추가적으로 설치할 필요가 없습니다.

### Redux

- Action은 state를 바꾸는 방식
- Dispatch는 Action을 발생시키는 것
- Reducer은 변화를 일으키는 함수로 Action의 결과로 state를 어떤식으로 바꿀지에 대해 구체적으로 정의하는 부분, 이전 상태는 건드리지 않고 새로운 상태객체를 만들어 반환하는 순수함수
- Store은 상태의 중앙저장소라고 보면된다. store안에 reducer와 같은 내장함수 등이 포함되어 있다.
- 상태를 전역적으로 관리하기에 어느 컴포넌트에 상태를 둬야할지 고민할 필요가 없다. 단방향 데이터 흐름, 불변성 유지가 매우 중요, flux아키텍처를 따른다. 여러 라이브러리를 동시에 사용, 액션하나를 추가하는데 작성이 필요한 부분이 많고 컴포넌트와 스토어를 연결하는 필수적인 부분들이 있어 코드량이 많아질 수 있다는 특징이 있다.
