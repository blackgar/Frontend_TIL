# 자바스크립트 면접 질문 정리

## 자바스크립트는 무슨 언어인가요?

- 웹 페이지에서 복잡한 기능을 구현할 수 있도록 하는 스크립팅 언어 또는 프로그래밍 언어입니다. 페이지의 내용이 주기적으로 갱신되거나, 사용자와 상호작용이 가능하거나, 애니메이션이 적용된 2D/3D 그래픽을 볼 수 있다면, Javascript가 관여하고 있을거라고 봐도 됩니다.
- 기능
  - 변수에 값을 저장할 수 있습니다.
  - 문자열(string)이라고 부르는 텍스트 조각을 조작할 수 있습니다.
  - 웹 페이지에서 발생하는 어떤 이벤트에 코드가 응답하도록 합니다.
  - 등등 동적인 화면을 보여주는 대부분의 동작은 자바스크립트로 구현합니다.

### HTML

- 웹 콘텐츠의 구조를 짜고 의미를 부여하는 마크업 언어입니다. 예를 들어 페이지의 어디가 문단이고, 헤더이고, 데이터 표와 외부 이미지/비디오인지 등을 정의하는 역할을 하는 언어라고 볼 수 있습니다.

### CSS

- HTML 콘텐츠에 스타일을 적용할 수 있는 스타일 규칙 언어입니다. 배경색을 추가하고, 글꼴을 바꾸고, 콘텐츠를 신문처럼 다열 레이아웃으로 배치할 수 있습니다.

### Browser API

- 웹 브라우저에 내장된 API로 현재 컴퓨터 환경에 관한 데이터를 제공하거나 여러가지 유용하고 복잡한 일을 수행합니다.
  - DOM(Document Object Model) : HTML 콘텐츠를 추가/제거/변경하고 동적으로 페이지에 스타일을 추가하는 등 HTML/CSS를 조작할 수 있게 해주는 API입니다. 페이지 위에 뜨는 팝업창이나, 새로운 콘텐츠가 화면에 나타난다면 DOM이 동작한 것이라고 보면 됩니다.
  - Geolocation API : 지리정보를 가져올 수 있는 API. Google 지도에서 현재 위치를 찾아 지도에 그릴 수 있는 이유가 바로 이 API를 활용하여 가능한 것입니다.
  - Canvas, WebGL API : 애니메이션을 적용한 2D와 3D 그래픽을 만들 수 있습니다.
  - HTMLMediaElement, WebRTC를 포함하는 오디오와 비디오 API
  - Twitter API
  - MAP API

## 변수 선언, 초기화, 할당의 차이점에 대해 설명해주세요.

### 변수

- 하나의 값을 저장하기 위해 확보된 메모리 공간 자체이자 변할 수 있는 데이터

### 변수명

- 메모리 공간을 식별하기 위한 식별자

```
var answer;
식별자가 "answer"인 변할 수 있는 데이터를 만든다.
```

### 변수 선언

- 변수를 정의하는 것. var, let, const 사용(ES6부터 let과 const 추가)

```
var answer;
```

### 변수 할당

- 변수가 선언된 후 대입 연산자를 통해 값을 넣어주는 과정을 의미한다.

```
answer = "developer"
```

### 변수 초기화

- 변수를 선언함과 동시에 값을 넣어주는 과정을 의미한다.

```
var answer = "developer"
```

## 데이터 타입에 대해 설명해주세요.

- 원시 값과 객체로 구분지을 수 있습니다.

### 원시 값(언어의 최고 로우 레벨에서 직접 표현되는 불변 데이터)

- Boolean, Null, Undefined, Number, BigInt, String, Symbol

### 객체(참조 타입)

- Object, Array, Function, Map, Set, WeakMap, WeakSet

## 생성자에 대해 설명해주세요.

- 생성자 함수는 유사한 객체 여러개를 쉽게 생성할 수 있는 것으로 일반 함수와 기술적인 차이는 없지만 두 관례를 따르는 것으로 알고 있습니다. 함수의 이름의 첫 글자는 대문자로 시작해야 하며, 반드시 "new" 연산자를 붙여서 실행해야 합니다.

## ⭐ this에 대해 설명해주세요.

### this란?

- javascript의 예약어입니다.
- this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(self-reference variable)입니다.
- this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있습니다.
- 자바스크립트 엔진에 의해 암묵적으로 생성됩니다.
- this는 코드 어디서든 참조할 수 있습니다.
- 함수를 호출하면 인자와 this가 암묵적으로 함수 내부에 전달됩니다. 인자와 this를 모두 지역 변수처럼 활용할 수 있습니다.
- this 바인딩은 함수 호출 방식에 의해 동적으로 결정됩니다. 어떤 위치에 있는지, 어디서 호출하는지, 어떤 함수에 있는지에 따라 참조값이 달라지는 특징이 있어 이에 대한 이해가 필수입니다.

### 바인딩이란?

- 식별자와 값을 연결하는 과정을 의미합니다.
- 변수선언은 변수 이름과 확보된 메모리 공간의 주소를 바인딩하는 것입니다.
- this바인딩은 this(키워드로 분류되지만 식별자의 역할을 합니다)와 this가 가리킬 객체를 바인딩하는 것입니다.
- 전역에서의 this는 window 전역 객체를 참조하고 Server-side(Node.js)에서는 global 객체를 의미합니다.
- 함수는 전역에 선언된 일반 함수와 객체 안의 메소드로 구분할 수 있습니다.
- 엄격모드의 this는 undefined가 바인딩 됩니다.

## call, apply, bind에 대해 설명해주세요.

### call

- 첫번째 인자로 this에 바인딩할 객체를 지정해주고, 두번째 인자부터는 호출하는 함수로 전달하는 매개변수가 오게 됩니다.
- 사용의 예시는 함수에 주어진 숫자와 문자열로 이루어진 매개변수들을 하나의 인자 arguments로 받아왔을 때 arguments는 유사 배열일 뿐 실제 배열이 아니기 때문에 관련 메서드를 사용할 수 없는 문제가 있는데 이때 Array의 prototype에서 join메서드를 call 메서드를 통해 적용할 수 있게 됩니다.

### apply

- call 과 유사한 방식이지만 함수로 전달하는 인자들을 배열 형태로 전달해야 합니다.

### bind

- call과 apply와 비슷하게 this 바인딩을 변경하는데 이 때 영구적으로 변경한다는 특징이 이씃ㅂ니다. 그리고 call, apply, bind를 통해서 변경할 수 없습니다. 또한, this를 바인딩 한 후 함수를 호출하는 것이 아니라 새로운 함수를 반환하게 됩니다.

## ⭐ 콜백 함수에 대해 설명해주세요.

- 다른 함수가 실행을 끝낸 뒤에 실행되는 함수를 의미합니다. 즉, 함수는 다른 함수의 인자로 쓰일 수도 있고 반환값으로 반환할수도 있습니다. 이런 함수를 고차함수라고 하는데, 이 때 인자로 넘겨지는 함수를 콜백함수라고 합니다. 또한, 함수를 등록해놓고 특정 이벤트나 시점에 의해 시스템에서 호출되는 함수도 콜백함수라고 합니다.

## ⭐ 콜백 지옥을 해결하는 방법을 설명해주세요.

- Promise나 async를 활용하는 방법이 있습니다.

## ⭐ Promise에 대해 설명해주세요.

- 비동기 연산이 종료된 이후에 결과를 알기 위해 사용하는 객체입니다(ES6). 이를 사용해 비동기 메서드를 마치 동기 메서드처럼 값을 반환할 수 있습니다. then과 catch의 체이닝을 통해 값을 반환 받아올 수 있습니다. 즉, 내용은 실행됐지만 결과를 아직 반환하지 않은 객체입니다.
- Promise는 대기(pending), 이행(fulfill), 거부(reject) 세 가지 상태 중 하나를 가지고 있습니다. Promise 기반 비동기 함수를 호출하게 되면 그 함수는 Promise 인스턴스를 반환하는데 이행되거나 거부될 때 Promise의 then과 catch 메서드에 의해 대기열에 추가된 처리기들이 호출됩니다.
- then(호출 성공시), catch(호출 실패시), finally(공통적으로 수행해야할 부분 처리)

## Promise.all() 에 대해 설명해주세요.

- 배열과 같이 순회 가능한 객체를 인자로 받습니다. 해당 배열안의 프로미스가 모두 이행되면 각각의 프로미스 결과 값을 담은 배열을 이행 결과 값으로 새로운 프로미스 객체를 반환합니다. 하지만, 이 때 배열 요소 중 하나의 프로미스라도 거부되는 즉시 다른 프로미스 이행 여부와 관계없이 거부 사유를 결과 값으로 반환합니다.

## ⭐ Promise와 Callback를 비교 설명해주세요.

- callback을 사용해 비동기 처리를 할 때는 결과값을 리턴 받기보다는 결과값을 통해 처리할 로직을 콜백 함수로 넘기는 스타일로 코딩을 해줘야 예상된 결과를 얻을 수 있습니다. 즉, 비동기 로직의 결과값을 처리하기 위해서 callback 안에서만 처리를 해야하는 문제가 있습니다. 하지만, 자바스크립트 프로젝트가 복잡해질수록 콜백 함수를 중첩해서 사용하게 되고 이는 가독성을 떨어지게 하는 문제를 야기합니다.

## ⭐ Async, Await이 뭔지 그리고 사용 방법을 설명해주세요.

- ES8부터 도입된 비동기함수 처리 방법입니다. Promise의 후속처리 메서드(then, catch, finally)없이 마치 동기적인 코드처럼 Promise가 처리결과를 반환하도록 구현할 수 있는 방법입니다. 비동기 함수는 항상 Promise객체를 반환하는데 async 함수는 언제나 async 키워드를 사용해 언제나 Promise를 반환합니다. 이 때 암묵적으로 반환값을 resolve하는 Promise를 반환합니다.
- await는 async 안에서만 작동합니다. await 키워드를 쓰게 되면 해당값이 반환되기 전까지 async 내부 함수는 일시 중단이 됩니다. Promise가 settled(수행완료) 상태가 될때까지 대기하다가 resolve한 처리결과 값을 반환합니다. 에러의 경우 try catch 구문으로 에러를 감지합니다.

## ⭐ Promise와 Async, Await의 차이를 설명해주세요.

- 에러 핸들링에서 Promise는 reject될경우 .catch()문을 통해 에러를 감지할 수 있지만, async/await의 경우 try-catch문을 사용해야 합니다. 다만, 전체적인 에러핸들링은 async가 유리합니다. 데이터는 받아왔지만 json.parse과정에서 문제가 발생할 경우 Promise 객체의 경우 then문 안에 catch문을 추가로 작성해야 하지만, async는 try catch문 한번이면 에러 핸들링이 가능합니다. 또한 에러 위치도 더 잘 알려주기에 에러핸들링을 위해서는 async await를 사용하는 것이 좋습니다.
- 코드 가독성의 경우 Promise는 .then()의 지옥 가능성이 있는 반면에 코드가 길어질수록 async/await의 가독성이 좋아집니다. 코드 흐름을 이해하기엔 async/await가 유리합니다.

## AJAX에 대해 설명해주세요.

-

## ⭐ var, let, const 차이를 설명해주세요.

- var 선언과 초기화를 최상단에서 진행. 할당은 코드로 왔을 때. 재선언 재할당 가능, 함수 스코프인 자바스크립트 특징으로 인해서 미처 변수가 선언되기도 전에 유효하다고 판정되기 때문에 호이스팅이 발생합니다.
- let 선언을 최상단에서 진행. 초기화와 할당이 코드에서 진행. 재선언 불가 재할당 가능, 블록 스코프
- const 선언, 초기화, 할당 모두 코드라인에서 진행. 재선언 불가 재할당 불가

## TDZ에 대해 설명해주세요.

- 자바스크립트의 특징 중 하나로 일시적 사각지대라고 부르는 현상입니다. 변수를 선언하고 초기화 하지 전에 변수가 사용될 때 이 변수는 현재 죽어있는(사용할 수 없는)변수가 되는 때 이 구간을 TDZ라고 합니다. const, let, class구문이 TDZ의 영향을 받고 var, function, import구문은 tdz의 영향을 받지 않기 때문에 호이스팅이 발생하게 됩니다.

## 함수 선언형과 함수 표현식의 차이에 대해 설명해주세요.

### 함수 선언식

- 함수명이 정의되어 있고, 별도의 할당 명령이 없는 것

### 함수 표현식

- 정의한 함수를 별도의 변수에 할당하는 것

### 차이점

- 주요한 차이점은 호이스팅에서 발생하게 됩니다. 함수 선언식은 함수 전체를 호이스팅하게 됩니다. 정의된 범위의 맨 위로 호이스팅되어 함수 선언 전에 함수를 사용할 수 있게 됩니다.
- 함수 표현식은 별도의 변수에 할당되기 때문에 선언부가 할당부가 나뉘어져 호이스팅 됩니다. 즉, 선언부만 호이스팅됩니다.

```
// 틀린 표현
sum(50, 50); // 100
minus(100, 50) // Uncaught TypeError: minus is not a function

function sum(a, b) { // 함수 선언식
  return a + b;
}

var minus = function (a,b) { // 함수 표현식
  return a - b;
}
// 올바른 표현
var minus = function (a,b) { // 함수 표현식
  return a - b;
}

sum(50, 50); // 100
minus(100, 50) // 50

function sum(a, b) { // 함수 선언식
  return a + b;
};
```

## ⭐ 이벤트 버블링과 캡처링에 대해 설명해주세요.

- 이벤트 버블링이란 자식태그에서 발생한 이벤트가 조상 태그까지 퍼지는 것. 캡쳐링은 반대로 부모태그에서 발생한 이벤트가 자식태그로 가는 것. stopPropagation으로 막을 수 있다. 캡쳐링을 막을때는 addEventListener에 세번쨰 인자로 캡쳐링 유무에 대한 선택이 가능하다.

## ⭐ 이벤트 위임에 대해서 설명해주세요.

- 하위 요소마다 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식을 말합니다. 이벤트 위임은 비슷한 방식으로 여러 요소를 다뤄야 할 때 사용됩니다. 이벤트 위임을 사용할 경우 요소마다 핸들러를 할당하지 않고도 공통 조상에 이벤트 핸들러를 할당하면 여러 요소를 한꺼번에 다룰 수 있다는 장점이 있습니다. 이를 위해서는 event target과 currentTarget 값을 이해하고 이 값을 적절하게 활용해서 코드를 작성하면 된다.

## 이벤트 위임의 동작 방식에 대해서 설명해주세요.

```
<table>
  <tr>
    <th colspan="3"><em>Bagua</em> Chart: Direction, Element, Color, Meaning</th>
  </tr>
  <tr>
    <td class="nw"><strong>Northwest</strong><br>Metal<br>Silver<br>Elders</td>
    <td class="n">...</td>
    <td class="ne">...</td>
  </tr>
  <tr>...2 more lines of this kind...</tr>
  <tr>...2 more lines of this kind...</tr>
</table>
```

- 위 코드에서 td를 눌렀을 때 td에 적힌 내용이 강조되게끔 구현하고 싶다면 아래처럼 전체를 감싸고 있는 table 태그에 event 핸들러를 할당해서 event.target.tagName이 td일때만 동작하게끔 로직을 구현하면 된다.

```
let selectedTd;

******************************************************************
table.onclick = function(event) {
  let target = event.target; // 클릭이 어디서 발생했을까요?

  if (target.tagName != 'TD') return; // TD에서 발생한 게 아니라면 아무 작업도 하지 않습니다,

  highlight(target); // 강조 함
};

function highlight(td) {
  if (selectedTd) { // 이미 강조되어있는 칸이 있다면 원상태로 바꿔줌
    selectedTd.classList.remove('highlight');
  }
  selectedTd = td;
  selectedTd.classList.add('highlight'); // 새로운 td를 강조 함
}
******************************************************************
```

- 아래 코드처럼 기능 향상을 할 수 있다.

```
table.onclick = function(event) {
  let td = event.target.closest('td'); // (1)

  if (!td) return; // (2)

  if (!table.contains(td)) return; // (3)

  highlight(td); // (4)
};
```

- 아래 코드처럼 버튼에 맞게 적절한 동작이 일어나도록 구현도 가능하다. 이게 이벤트 위임이다.

```
<div id="menu">
  <button data-action="save">저장하기</button>
  <button data-action="load">불러오기</button>
  <button data-action="search">검색하기</button>
</div>

<script>
  class Menu {
    constructor(elem) {
      this._elem = elem;
      elem.onclick = this.onClick.bind(this); // (*)
    }

    save() {
      alert('저장하기');
    }

    load() {
      alert('불러오기');
    }

    search() {
      alert('검색하기');
    }

    onClick(event) {
      let action = event.target.dataset.action;
      if (action) {
        this[action]();
      }
    };
  }
```

## Window 객체란 무엇인가요?

### Window

- 브라우저의 요소들과 자바스크립트 엔진 그리고 모든 변수를 담고 있는 (전역) 객체입니다.
- 인터넷 브라우저에서 탭, 주소창, 즐겨찾기, 툴바 등을 제외한 웹사이트가 보여집니다. 이때 브라우저 전체를 담당하는 것이 Window 객체이고 웹사이트만 담당하는게 Document 객체입니다. Window안에 Document가 있습니다.
- window는 모든 객체의 조상이기 때문에, 원래 window.parseInt와 같이 메서드 앞에 window를 써야하지만, 생략이 가능합니다.
- window.parseInt, String, Boolean, Number, Function, Array, 내가 선언한 변수 등이 모두 window.으로 사용할 수 있는 것들입니다.
- 전역 객체 중 자주 쓰이는 것들 중 document를 DOM이라고 부르고 나머지는 브라우저에 대한 정보들을 가지고 있어 BOM(Browser Object Model)이라고 부릅니다.

### BOM

- 브라우저나 운영체제에 대한 정보(navigator.userAgent)가 있고 userAgent를 바탕으로 분석 사이트에서는 고객에 대한 정보를 분석하게 됩니다. 이외에도 screen, location, history 등의 메서드를 통해 브라우저 정보를 제공합니다.

## ⭐ 호이스팅과 발생하는 이유에 대해 설명해주세요.

- 호이스팅이란 var로 선언한 표현식이나 function 선언문 등을 실행 단계에서 해당 scope의 최 상단으로 올려서 실행하는 부분을 말합니다. 자바스크립트는 코드를 실행하기 전에 var 선언문과 function 선언문을 해당 스코프의 최상단으로 올리는 이유는 자바스크립트 변수 생성과 초기화 즉, 선언과 초기화와 할당이 분리되어 진행되기 때문입니다. 주의할 부분은 변수에 값이 초기화 및 할당이 되어 있는지 여부에 따라 var과 function 선언문이 다르게 동작합니다.

```
<!-- 값이 있다면 기존의 값이 함수를 덮습니다. -->
var getName = 'olaf';
function getName(){
  console.log('olaf');
}
console.log(typeof getName); // string

<!-- 반면에 undefined 일 경우 함수가 채워줍니다. -->
var getName; // undefined
function getName() {
     console.log("appear");
}
console.log(typeof getName); // function
```

## 스코프 (Scope)에 대해 설명해주세요.

- 해당 변수가 정의되어 있는 영역, 즉 정의된 변수를 사용할 수 있는 소스코드의 집합을 말합니다. 자바스크립트는 기본적으로 함수 스코프를 사용하므로 함수 내에 정의된 변수는 해당 함수 내에서만 사용할 수 있고 유효합니다.

## 스코프 체인에 대해 설명해주세요.

- 전역 변수는 전역 객체의 프로퍼티입니다. 지역 변수는 그런 규정이 없지만, 변수를 각 함수 호출과 연관된 객체의 프로퍼티로 생각할 수 있습니다. 그래서 지역 변수를 한 객체의 프로퍼티라고 생각할 때, 자바스크립트의 모든 코드는 스코프 체인을 가지고 있습니다. 이러한 코드의 유효 범위 안에 있는 변수를 정의하는 객체의 체인, 즉 리스트를 말합니다.
- 자바스크립트가 변수의 값을 얻으려고 할 때 스코프 체인은 객체의 리스트이므로 첫 번째 객체에서 변수를 찾아보고 없으면 그다음 객체를 찾아보는 식으로 모든 객체를 탐색했는데도 해당 변수가 없다면 reference error을 반환합니다. 스코프의 꼬리에 꼬리를 물고 범위를 넓혀나가는 과정.

## ⭐ 클로져(Closure)에 대해 설명해주세요.

- 클로저를 이해하기 위해서는 렉시컬 스코프에 대해서도 이해해야 한다.

### 렉시컬 스코프란?

- 함수가 정의(호출 X)된 시점의 스코프 체인을 사용해서 함수가 실행되는 규칙입니다. 중요한 것은 함수가 호출된 시점이 아니라 정의된 시점이라는 것인데, 한 예로 어떠한 함수가 함수내의 지역 변수를 사용하여 또다른 함수를 반환한다고 가정했을 때 이 함수가 호출 시점보다 전에 있으면 함수가 먼저 실행돼서 함수 내의 지역변수가 사라질 것이라고 생각할 수 있지만, 그렇지 않고 함수가 정의되었을 때의 스코프 체인을 사용해서 함수가 정의되었을 때 바인딩 된 지역변수를 활용해 리턴된 함수가 동작하게 됩니다.
- 즉, 함수가 호출되면 호출과 관련된 지역 변수를 보관하는 객체가 생성되고 이 객체는 함수의 스코프 체인에 추가됩니다. 이후 함수가 반환되면 보관하던 객체가 사라지고 바인딩된 변수가 스코프 체인에서 제거됩니다. inner 함수가 있을 때는 스코프 체인에 대한 참조가 있고 이 스코프 체인은 객체와 바인딩된 변수들을 참조하고 있습니다.

```
function wrapElements(a) {
  var result = [], i, n;
  for (i = 0, n = a.length; i < n; i++) {
    result[i] = function () { return a[i]; }
  }
  return result;
}
var wrapped = wrapElements([10, 20, 30, 40, 50]);
var f = wrapped[0];
f(); // undefined

<!-- let으로 선언 -->
function wrapElements(a) {
  var result = [], n;
  for (let i = 0, n = a.length; i < n; i++) {
    result[i] = function () { return a[i]; }
  }
  return result;
}
var wrapped = wrapElements([10, 20, 30, 40, 50]);
var f = wrapped[0];
f(); // 10
```

- 위 예시에서 확인할 수 있듯이 이미 함수가 먼저 동작하므로 i는 5가된 상태로 wrapped라는 변수에 함수가 호출됩니다. i는 5인 상태로 함수가 호출됐기 때문에 내부 코드에서 보면 a[5] 값은 없기 때문에 undefined를 반환합니다. 이 때 원하는 결과를 얻기 위해서는 i를 let으로 선언하게 되면 블록 스코프로 지역 변수를 사용하기 때문에 공유하지 못하는 현상으로 인해 함수가 호출될 때 매번 새로운 값으로 돌아가므로 정상적으로 f() 값이 10이 나오게 된다.

## 실행 컨텍스트에 대해 설명해주세요.(활성 객체 제외)

- 자바스크립트가 왜 이렇게 동작하는지를 설명해주는 요소입니다.
- 코드의 실행 환경이라고 생각할 수 있다.

```
var name = 'zero'; // (1)변수 선언 (6)변수 대입
function wow(word) { // (2)변수 선언 (3)변수 대입
  console.log(word + ' ' + name); // (11)
}
function say () { // (4)변수 선언 (5)변수 대입
  var name = 'nero'; // (8)
  console.log(name); // (9)
  wow('hello'); // (10)
}
say(); // (7)
// nero, hello zero
```

- 처음 코드를 실행할 때 (브라우저가 스크립트를 로딩해서 실행할 때) 모든 것을 포함하는 전역 컨텍스트가 생깁니다. 모든 것을 관리하는 환경으로 페이지가 종료될 때까지 유지됩니다. 그리고 함수 컨텍스트가 있는데, 함수 스코프를 자바스크립트의 특성으로 함수를 호출할 때마다 함수 컨텍스트가 하나씩 생기게 됩니다.
- 컨텍스트의 네 가지 원칙
  - 먼저 전역 컨텍스트 하나를 생성하고 함수 호출 시마다 함수 컨텍스트 생성.
  - 컨텍스트 생성 시 컨텍스트 안에 변수객체(arguments, variable), scope chain, this가 생성됩니다.
  - 컨텍스트 생성 후 함수가 실행되는데, 사용되는 변수들은 변수 객체 안에서 값을 찾고, 없다면 스코프 체인을 따라 올라가며 찾습니다.
  - 함수 실행이 마무리되면 클로저를 제외한 해당 컨텍스트는 사라집니다. 페이지가 종료되면 전역 컨텍스트가 사라집니다.
- 위 원칙에 따라 위 코드를 실행하면
  - 전역 컨텍스트 생성 후 변수객체, scope chain, this가 컨텍스트로 들어오게 됩니다. arguments(함수의 인자)는 없고 variable(해당 스코프의 변수들)은 name, wow, say가 있습니다. scope chain(자신과 상위 스코프들의 변수객체)은 자기 자신인 전역 변수객체가 됩니다. this는 따로 설정되어 있지 않으므로 window가 할당되게 됩니다.
  - wow랑 say는 호이스팅 때문에 선언과 동시에 값이 대입이 되고 이 후 variable의 name에 "zero"값이 대입됩니다.
  - 함수 컨텍스트에서는 say()를 만나는 순간 새로운 컨텍스트인 say 함수 컨텍스트가 생기게 됩니다. 이때 전역 컨텍스트는 그대로 있는 상태입니다. say 함수 컨텍스트 내부에는 arguments는 없고 variable은 name만 있습니다. scope chain은 say 변수 객체와 상위의 전역 변수객체입니다. this는 따로 설정해주지 않았기에 window입니다. console.log(name)에서는 내부 name = "nero"에서 "nero"라는 값을 가져오게 됩니다. wow("hello")에서는 arguments hello, scope chain은 wow스코프와 전역 스코프가 됩니다. 이때 선언할 때 이미 스코프 체인이 정해졌기에 say 스코프가 wow 컨텍스트의 scope chain이 아니게 됩니다. variable은 없고 this는 window가 됩니다. 이렇게 작동하게끔 실행 환경을 구축하는 것이 컨텍스트입니다.

## 렉시컬 환경(Lexical Environment)에 대해 설명해주세요.

- block, function, script를 실행하기 앞서 생성되는 특별한 객체로 실행할 스코프 범위 안에 있는 변수와 함수를 프로퍼티로 저장하는 객체다. 우리가 소스코드를 실행하면서 필요한 변수의 값을 이 렉시컬 환경이라는 객체에서 식별자 이름을 키로 찾는다고 생각하면 된다.
- Environment Record라는 모든 로컬 변수들을 프로퍼티로 갖는 객체와 외부 코드와 연관된 외부 렉시컬 환경에 대한 참조로 구성되어 있다.

## 자바스크립트에서 일어나는 데이터 형변환에 대해 설명해주세요.

- 암시적 형변환과 명시적 형변환이 있습니다.

### 암시적 형변환

- 자바스크립트 엔진이 필요에 따라 자동으로 데이터 타입을 변환시키는 것을 말합니다.
- 산술연산자

  ```
  // + 연산자
  number + number // number
  number + string // string
  string + string // string
  string + boolean // string
  number + boolean // number
  50 + 50; //100
  100 + “점”; //”100점”
  “100” + “점”; //”100점”
  “10” + false; //”100"
  99 + true; //100

  // 다른 연산자(-,*,/,%)
  string * number // number
  string * string // number
  number * number // number
  string * boolean //number
  number * boolean //number
  “2” * false; //0
  2 * true; //2
  ```

  - 동치 비교
    아래 예제는 엄격하지 않은 동치(==)비교이며, 아래의 결과값은 좌우항 변환할 경우 모두 '0==0이기 때문에' 'true'이다. 여기서 유의해야할 점은 위의 비교는 엄격하지 않은 동치 비교일 경우이기 때문에, 두 값을 비교할때 데이터타입을 변환하지 않는 엄격한 동치(===)비교와 혼동되지 않도록 한다.

  ```
  null == undefined // true 0 == 0
  “0” == 0 // true 0 == 0
  0 == false // true 0 == 0
  “0” == false // true 0 == 0
  ```

### 명시적 형변환

- 개발자가 의도를 가지고 데이터 타입을 변환시키는 과정을 말합니다.
- 타입을 변경하는 기본적인 방법은 Object(), Number(), toString()과 같은 함수를 이용하는데 new 연산자가 없다면 사용한 함수는 타입을 변환하는 함수로써 사용됩니다.

```
var trans = 100; //Number
Object(trans); //100
console.log(typeof trans); //Number
toString(trans); //”100"
console.log(typeof trans); //String
Boolean(trans); //true
console.log(typeof trans); //Boolean
```

- Number() & parseInt() & parseFloat() 문자열 -> 숫자로 변환
  - Number은 정수형과 실수형의 Number 데이터 타입 그자체로 변환하는 것이다. 문자열을 숫자로 바꿀때 일반적으로 사용한다. 숫자로 변환되지 않으면 NaN 반환
  ```
  const falsy1 = null;
  Number(falsy1); // 0;
  const falsy2 = '';
  Number(falsy2); // 0;
  const falsy3 = false;
  Number(falsy3); // 0;
  const truthy1 = [];
  Number(truthy1); // 0;
  const truthy2 = true;
  Number(truthy2); // 1;
  const truthy3 = {};
  Number({}); // NaN;
  ```
  - parseInt()는 정수형 숫자로 변환한다. 2진수, 8진수, 16진수 등 다양한 진수들을 인식한다음 10진수로 변환해서 반환해준다. 문자열로 된 부분에서 숫자(정수)부분만 뽑아서 변환해주는 특징이 있다.
  ```
  parseInt(“27”) //27
  parseInt(0033); //27
  parseInt(0x1b); //27
  parseInt(“ 2”); //2
  parseInt(“ 2ㅎ”); //2
  parseInt(“ ㅎ2”); //NaN
  ```
  - parseFloat()는 부동 소수점의 숫자로 변환한다. parseInt()와는 달리 parseFloat()는 항상 10진수를 사용하며 parseFloat() 또한 앞부분 빈 공백을 두고 나오는 문자는 모두 무시되어 NaN을 반환한다.
  ```
  parseFloat(“!123”); //NaN
  parseFloat(“123.123456”); //123.123456
  parseInt(“123.123456”); //123
  parseFloat(“ 123.123456”); //123.123456
  parseFloat(“ a123.123456”); //NaN
  ```
  - 단항연산자(unary-operators)로 숫자형 타입 변경하는 방법도 있다.
    ```
    +'1000'; // 1000
    +'-1000'; // -1000
    +'Infinity'; // Infinity
    -'1000'; // -1000
    +true; // 1
    +[]; /// 0
    +false; // 0
    +null; // 0
    +'';// 0
    ```
- String() & toString() & toFixed() 숫자 -> 문자열

  - String()

  ```
  String(123); //”123"
  String(123.456); //”123.456"
  ```

  - toString() : 주어진 값을 문자열로 변환 후 반환. 인자로 몇진수로 반환할지 선택할 수 있고 인자를 전달하지 않으면 10진수로 변환.

  ```
  var trans = 100;
  trans.toString(); //”100"
  trans.toString(2); //”1100100"
  trans.toString(8); //”144"
  var boolT = true;
  var boolF = false;
  boolT.toString(); //”true”
  boolF.toString(); //”false”
  ```

  - toFixed() : toFixed()의 인자를 넣으면 인자값만큼 반올림하여 소수점을 표현하며 소수점을 넘치는 값이 인자로 들어오며 '0'으로 길이를 맞춘 문자열을 반환한다.

  ```
  var trans = 123.456789;
  var roundOff = 99.987654;
  trans.toFixed(); //”123"
  trans.toFixed(0); //”123"
  trans.toFixed(2); //”123.46"
  trans.toFixed(8); //”123.45678900"
  roundOff.toFixed(2); //”99.99"
  roundOff.toFixed(0); //”100"
  ```

- Boolean() A Type => Boolean Type 변환
  - Boolean() : 자바스크립트에서는 Boolean타입으로 변경은 Boolean 또는 부정연산자(!)를 사용하여 Boolean값을 만들어낸다. 부정연산자는 의미그대로 !을 사용하면 Boolean() 반대의 값을 리턴한다.
  ```
  Boolean(100); //true
  Boolean(“1”); //true
  Boolean(true); //true
  Boolean(Object); //true
  Boolean([]); //true
  Boolean(0); //false
  Boolean(NaN); //false
  Boolean(null); //false
  Boolean(undefined); //false
  Boolean( ); //false
  const numb1 = 0;
  Boolean(numb1); // false
  !!numb1; // false
  !numb1; // true
  ```

## 자바스크립트가 동적 언어인 이유는 무엇인가요?

- 웹 페이지와 앱의 서로 다른 상황에서 서로 다른 화면을 보여줄 수 있고, 필요하면 새로운 콘텐츠를 생성할 수 있는 동적 코드이기 때문입니다.

### 동적 언어와 정적 언어

- 정적 언어 (Statically Typed Language)
  - 컴파일 시간에 변수의 타입이 결정되는 언어.
  - 타입 즉, 자료형을 컴파일 시에 결정하는 것.
  - C, C++, Java 등은 대표적인 정적 언어이다.
  - 정적 언어는 변수에 들어갈 값의 형태에 따라 자료형을 지정해주어야 한다.
  - 컴파일 시에 자료형에 맞지 않는 값이 들어있을 경우 컴파일 에러가 발생한다.
  - 컴파일 시간에 변수의 타입을 체크하므로 사소한 버그들을 쉽게 체크할 수 있는 장점이 있다.
  - 즉 타입 에러로 인한 문제점을 초기에 발견할 수 있어 타입의 안정성이 올라간다.
- 동적 언어 (Dynamically Typed Language)
  - 런타임에 타입이 결정되는 언어.
  - 즉, 소스가 빌드될 때 자료형을 결정하는 것이 아니라 실행 시 결정된다.
  - 매번 타입을 써줄 필요가 없기 때문에 프로그래머가 빠르게 코드를 작성할 수 있다.
  - JavaScript, Ruby, Python 등은 대표적인 동적 언어이다.
  - 런타임까지 타입에 대한 결정을 끌고 갈 수 있기 때문에 선택의 여지가 있다.
  - 실행 도중에 변수에 예상치 못한 타입이 들어와 Type Error가 발생하는 경우가 생길 수 있다.

## 프로토타입에 대해 설명해주세요.

-모든 객체들이 메소드와 속성들을 상속 받기 위한 템플릿입니다. 모든 객체는 자신의 부모 역할을 하는 프로토타입 객체의 참조 링크를 가지고 있으며, 이 링크를 통해 프로토타입으로부터 프로퍼티나 메서드를 상속받게 됩니다. 이를 통해 자바스크립트는 객체 지향의 상속 개념을 구현하고 있습니다. 동일한 프로토타입을 상속받은 객체는 모두 같은 프로퍼티와 메서드를 공유하게 됩니다.

- 스코프 체인처럼 프로토타입도 사용가능한 범위인 프로토타입 체인이 존재합니다. 상위 프로토타입과 연쇄적으로 연결된 구조를 의미합니다. 프로퍼티나 메서드에 접근하기 위해 이 연결구조를 따라 차례대로 검색하는 것을 프로토타입 체이닝이라고 합니다.
- 최상위에 Object.prototype이 있습니다.
- 같은 생성자로부터 만들어진 객체들은 모두 원형 객체를 공유합니다.

## 깊은 복사와 얕은 복사에 대해 설명해주세요.

- 깊은 복사는 실제 값을 새로운 메모리 공간에 복사해서 저장하고 있는 것을 의미하고, 얕은 복사는 기존에 가지고 있는 값이 들어있는 메모리의 주소값을 복사해 들고 있는 것입니다. 즉 참고하고 있는 실제 값과 얕은 복사한 값과 같다고 볼 수 있습니다.

## 불변성을 유지하려면 어떻게 해야하나요?

- 불변성이랑 메모리에 저장된 값을 변경하지 않는 것을 말합니다. 무분별한 상태의 변경을 방지하고 상태의 변경을 추적하기 쉽게 하기 위해 불변성을 유지하는 것이 좋습니다.
- 전역변수의 남용을 최대한 자제하고 javascript에는 불변성을 유지하는 값들과 그렇지 않은 값들로 나누어져있습니다. 일반적으로 Boolean, Number, String과 같은 원시 타입들은 불변성을 유지하고 Object는 변경가능하기 때문에 객체 값의 경우 직접 객체를 새로 생성해주거나 스프레드 연산자를 통해 새로 생성한 객체를 활용하는 방법이 있습니다.

## Blocking과 Non- Blocking에 대해 설명해주세요.

- 블로킹은 하나의 작업을 수행하는 동안 다른 작업을 수행하지 못하는 것을 말하고 Non-Blocking은 여러 작업을 동시에 수행할 수 있는 환경을 말합니다.

## ⭐ 동기와 비동기에 대해 설명해주세요.

### 동기

- 데이터의 요청과 결과가 한 자리에서 동시에 일어나는 것으로 코드가 순차적으로 동작한다는 것을 의미하기도 합니다. 즉, 요청을 하게 되면 시간이 얼마가 걸리건 요청한 자리에서 결과가 주어진다는 것입니다. 설계가 간단하고 직관적이라는 장점이 있지만, 결과가 주어질 때까지 다른 동작을 못하고 대기해야 한다는 단점이 있습니다.

### 비동기

- 비동기는 요청한 결과가 동시에 일어나지 않을거라는 일종의 약속입니다. 그래서 요청에 따른 결과가 반환되는 동안 다른 작업을 수행할 수 있다는 장점이 있지만, 설계가 어렵다는 단점이 있습니다.

## ES6에서 새로 생긴 기능을 아는대로 말씀해주세요.

- const, let, arrow function, template literal, default parameters, array and object destructing, import and export, promise, rest parameter and spread operator, classes

## undefined, null, undeclared를 비교해주세요.

### undefined

- 접근 가능한 스코프에 변수가 선언되었으나 아무런 값도 할당되지 않은 상태 즉, 데이터 타입이 정의되지 않았다는 것을 의미합니다.

### null

- 변수를 선언하고 의도적으로 빈값인 null을 할당할 때 사용합니다. null은 타입은 객체이고 비어있는 변수라는 차이가 있습니다.

### undecleared

- 접근 가능한 스코프에 변수가 선언조차 되어 있지 않은 상태를 말합니다. 결과로는 is not defined라는 오류를 반환하지만 타입은 undefined 입니다.

### NaN(Not a Number)

- 표현 불가능한 수치형 결과를 나타내는 값이며, 유효한 숫자가 아니라는 것을 나타냅니다(컴퓨터가 표현할 수 없는 숫자값). 타입은 N umber입니다.

## 자바스크립트를 멀티 쓰레드처럼 사용하는 방법이 뭔가요? / 자바스크립트에서 비동기 로직이 어떻게 되나요?

- 싱글스레드는 하나의 콜스택이 있고 한번에 하나의 동작만을 할 수 있습니다. 문맥교환 작업을 요구하지 않습니다(하나의 프로세스가 CPU를 사용하다 다른 프로세스가 CPU를 사용하도록 하기 위해 이전의 프로세스 상태를 보관하고 새로운 프로세스의 상태를 적재하는 과정). 자원 접근에 대한 동기화를 신경쓸 필요가 없습니다. 프로그래밍 난이도가 쉽고 자원을 적게 소모합니다.
- 자바스크립트는 싱글스레드라 Memory Heap, 하나의 Call Stack이 있습니다. 하지만 Web APIs 와 Event Loop , Callback Queue 를 통한 비동기 처리가 가능합니다. 결국 모든 것은 Call Stack에 쌓여 처리되지만, Callback Queue와 Event Loop을 통해 처리가 지연될 수 있는 비동기 로직들을 처리할 수 있게 해줍니다.
- 멀티스레드는 여러개의 콜스택이 있고 한번에 여러 동작이 가능합니다.

### 이벤트 루프란?

- 함수가 호출되면 call stack에 추가가 되고 내부 로직들이 한줄씩 call stack에 들어와서 처리되는 동기식 처리가 진행됩니다. 그러다가 setTimeout과 같은 비동기로 처리해야 되는 함수가 call stack으로 들어오게 되면 브라우저가 제공하는 webAPI를 통해 대기열Queue에 들어가게 되고 event Loop는 callstack이 모두 비워지면 대기열 Queue에 있던 함수들을 callstack으로 다시 넣어서 실행시키는 역할을 합니다.
- Heap : 메모리 할당이 발생하는 곳
- Call Stack : 실행된 코드의 환경을 저장하는 자료구조로, 함수 호출 시 이곳에 저장된다. 어떤 함수를 저장하면 스택에 쌓고 또 다른 함수를 호출하면 그 다음 스택에 쌓이면서 가장 위에 쌓인 함수를 가장 먼저 처리한다. LIFO(Last In First Out)
- Web APIs : Web API는 브라우저에서 제공하는 API로 DOM, Ajax, TimeOut 등이 있다.
  CallStack에서 실행된 비동기 함수는 Web API를 호출하고, Web API는 콜백 함수를 Task Queue에 넣는다.
- Callback Queue : 함수를 저장하는 자료구조로, Call Stack과 다르게 가장 먼저 들어온 함수를 가장 먼저 처리한다.
- Event Loop : 이벤트 루프는 call stack이 다 비워지면 callback queue에 존재하는 함수를 하나씩 call stack으로 옮기는 역할을 한다.

-

## 태스크 큐와 마이크로 태스트 큐에는 어떤 함수가 들어가나요?

- 테스크 큐 일반적으로 콜백함수를 처리하기 위해 저장해두는 공간으로 마이크로 테스크 큐와 매크로 스크큐로 나뉘어집니다.
- 둘 다 콜백함수가 들어가지만 어떤 함수를 실행하느냐에 따라 들어가는 큐가 달라지게 됩니다. 태스크 큐에는 setTimeout, setInterval, Input/Output, UI렌더링과 같은 콜백함수가 들어가고 마이크로 태스크 큐에는 Promise의 콜백함수가 들어가게 됩니다.
- 이 때 핵심은 마이크로태스크가 먼저 처리되고 그다음 매크로 태크스 큐의 콜백함수들이 처리됩니다.

## requestAnimationFrame에 대해 설명해주세요.

-

## 비동기적으로 실행되는 것을 동기적으로 코딩하는 방법이 있나요?

- async, await와 같은 방법?

## map과 forEach, reduce에 대해 설명해주세요.

-

## 자바스크립트의 메모리 관리에 대해 아는 대로 설명해주세요

- 자바스크립트는 객체가 생성될 때 자동으로 메모리를 할당하고 할당된 메모리를 명시적으로 사용하고 더 이상 필요하지 않을 때 암묵적으로 해제합니다. 이에 대해서는 좀 문제가 되기도 합니다. 개발자가 메모리 관리에 대해 고민할 필요가 없다는 인식이 생기게 되는 원인인데, 실제로는 그렇지 않습니다. 왜냐하면 할당된 메모리가 더 이상 필요없을 때를 알아내는 것이 어렵기 때문입니다. 이 과정에서 갈비지 컬렉션이 생겨나게 됩니다. 가비지 콜렉터의 목적은 메모리 할당을 추적하고 할당된 메모리 블록이 더 이상 필요하지 않게 되었는지를 판단하여 회수하는 것입니다. 하지만, 어떤 메모리가 여전히 필요한지 아닌지를 판단하는 것은 비결정적 문제이기 때문입니다.
- reference counting 알고리즘(더 이상 필요 없는 오브젝트는 어떤 다른 오브젝트도 참조하지 않는 오브젝트라고 결정하는 알고리즘 혹은 이를 참조하는 다른 오브젝트가 하나도 없는 경우), mark and sweep 알고리즘(더 이상 필요없는 오브젝트를 닿을 수 없는 오브젝트로 정의)

## 클래스에 대해 설명해주세요.

- 객체를 생성하기 위한 템플릿입니다. 클래스는 데이터와 이를 조작하는 코드를 하나로 추상화합니다. 자바스크립트에서 클래스는 프로토타입을 이용해서 만들어졌지만 ES5의 클래스 의미와는 다른 문법과 의미를 가집니다.

## 즉시 실행 함수 (IIFE)에 대해 설명해주세요.

- 정의되자마자 즉시 실행되는 함수
- 필요 없는 전역 변수의 생성을 줄일 수 있고, private한 변수를 만들 수 있습니다. 자체적으로 스코프를 가지게 되므로 클로저의 사용 목적과도 비슷합니다. 그래서 단 한 번의 사용이 필요한 함수나 자바스크립트 모듈(라이브러리)에서 많이 사용합니다.

## 엄격 모드에 대해 설명해주세요.

- ES5가 등장하면서 새로운 기능들이 추가되고 기존 기능 중 일부가 변경되면서 기존에 있던 코드들과의 호환성 문제가 발생하게 됩니다. 이 때 이러한 호환성 문제를 막기 위해 ES5의 기본 모드에서는 변경사항이 활성화되지 않도록 설계된 방법입니다. 기존에 무시되던 에러들을 표시하거나, Javascript 엔진의 최적화 작업을 어렵게 만드는 문제들을 바로잡게 됩니다. 그래서 가끔 엄격 모드의 코드는 비엄격 모드의 동일한 코드보바 더 빨리 동작할때도 있습니다. ECMAScript의 차기 버전들에서 정의될 문법들을 금지합니다.

## 콜 스택 (Call Stack)과 힙 (Heap)에 대해 설명해주세요.

-

## Rest 연산자와 Spread 연산자에 대해 설명해주세요.

- 압축 / 압축 풀기

## 제너레이터에 대해 설명해주세요.

-

## 이터러블과 이터레이터 프로토콜에 대해 설명해주세요.

-

-

## 자바스크립트 자료구조에 대해서 아는대로 설명해주세요.

- 연결 리스트, 큐, 스택, 해시테이블, Map, Set, Graph

## 화살표 함수와 일반 함수의 차이점에 대해서 설명해주세요.

- this

  - 일반함수

    - 아래는 일반 함수에서 this가 바인딩 되는 상황이다.
    - 함수 실행시에는 전역(window) 객체를 가리킨다.
    - 메소드 실행시에는 메소드를 소유하고 있는 객체를 가리킨다.
    - 생성자 실행시에는 새롭게 만들어진 객체를 가리킨다.
    - 일반 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정되는 것이 아니고,
    - 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 동적으로 결정된다.

  - 화살표 함수
    - 화살표 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정된다.
    - 화살표 함수의 this 언제나 상위 스코프의 this를 가리킨다.(Lexical this)
    - 또한 call, apply, bind 메소드를 사용하여 this를 변경할 수 없다.

- 생성자 함수

  - 일반함수는 생성자 함수로 사용할 수 있다.
  - 화살표 함수는 생성자 함수로 사용할 수 없다. prototype 프로퍼티가 없기 때문.

- argunments

  - 일반 함수에서는 함수가 실행될 때 암묵적으로 arguments 변수가 전달되어 사용할 수 있다.

    ```
    function fun() {
    console.log(arguments); // Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]
    }
    fun(1, 2, 3);
    ```

  - 화살표 함수에서는 arguments가 전달되지 않는다.

    ```
    const arrFun = () => {
    console.log(arguments); // Uncaught ReferenceError: arguments is not defined
    };
    fun(1, 2, 3);
    ```
