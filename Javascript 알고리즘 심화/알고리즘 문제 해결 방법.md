# 알고리즘 문제 해결 방법

## 알고리즘이란?

> 특정 작업을 달성하기 위한 과정이나 일련의 단계를 의미

<br/>

## 어떻게 알고리즘 역량을 향상시키는가?

<!-- Define what an algorithm is
Devise a plan to solve algorithms
Compare and contrast problem solving patterns including frequency counters, two pointer problems and divide and conquer -->

> 문제 해결을 위한 계획을 수립한다. 일반적인 문제 해결 패턴을 파악한다. 그리고 단계별로 문제에 접근한다.

### 문제 해결을 위한 5단계

- 문제 이해하기(Understand the Problem)

  ```
  문제를 스스로의 방식으로 다시 생각해볼 수 있는가? => 면접관의 말을 그대로 생각하는게 아니라 스스로의 방식으로 바꿔서 질문이 무엇인지를 이해하는 것.
  입력값의 형태는 어떠한가?
  어떤 출력값이 나와야 하나?
  문제에 대한 해결책에서 나와야 할 결과가 무엇인가?
  출력값은 어떤 형태여야 하나?
  함수에서 반환해야 하는 결과는 무엇인가?
  입력값이 출력값을 결정할 수 잇는가?
  이러한 질문들을 해결할 수 있을 충분한 정보가 주어졌는가?
  해당 정보만 사용해도 예상되는 출력값이 반환되는가?
  문제의 일부인 데이터의 중요한 부분에 어떻게 라벨을 지정할 수 있는가?
  ```

  ```
  두 숫자를 더해서 합을 반환하는 함수를 만든다.

  1. 문제를 스스로의 방식으로 다시 생각해볼 수 있는가?
    - 더하기를 수행한다.
  2. 입력값의 형태는 어떠한가?
    - 그냥 숫자만 들어갈수도 있지만, 자바스크립트의 경우 엄청 큰 숫자를 더하게 되면 자료형을 Infinity로 인식해서 계산이 안될수도 있고 숫자를 두개뿐만 아니라 그냥 하나만 사용하고 싶을 수도 있고 3~10개 그 이상의 숫자를 더하고 싶을 수도 있다. 이를 고민해야 한다.
  3. 문제에 대한 해결책에서 나와야 할 결과가 무엇인가?
    - 문자열로 반환해야 할지, 숫자로 반환해야 할지, 문제를 잘 읽고 거기에 맞는 형태로 반환할 수 있어야 한다.
  4. 이러한 질문들을 해결할 수 있을 충분한 정보가 주어졌는가?
    - 만약 입력값을 하나만 입력했을 때 두번째 더하는 숫자에는 어떠한 수를 더해줘야하는가? 0? undefined? 이에 대해 생각해보아야 한다.
  5. 문제의 일부인 데이터의 중요한 부분에 어떻게 라벨을 지정할 수 있는가?
    -
  ```

- 구체적인 예시 알아보기(Explore Concrete Examples)

  ```
  사용자의 입장에서 생각해보는 것이 좋다.
  인스타그램 같이 큰 회사에서는 사용자의 작업이 어떤 결과를 발생시킬지에 대해서 고려해야 한다. 작은 규모의 단위 테스트로 이를 확인하는 방법이 있다.

  문제를 마주치면 간단한 예시로 접근한 후 복잡한 예시로 발전시킨다.
  비어있는 Input에 대해서 생각해보고 유효하지 않은 Input에 대해서도 생각해본다.
  ```

  ```
  문자열을 받아서 문자열의 글자 수를 반환하는 함수를 만든다.
  charCount("aaaa"; // {a:4}
  charCount{"hello"}; // {h:1, e:1, l:2, o:1}
  charCount {"my phone number is 1823123"}; // 공백에 대해서는 어떻게 처리할 것인가?
  charCount{"Hello hi"}; // 대소문자 구분은 어떻게 할 것인가?
  charCount{""} // 빈값을 어떻게 반환할 것인가 0? false?
  charCount(12) // 이때는 어떻게 반환할 것인가?
  ```

- 문제를 세분화하기(Break it Down)
  ```
  밟아야할 단계에대해서 명확하게 작성해 나가는 것이 중요하다. 순서도를 작성하거나 pseudo코드를 작성해보는 것도 좋다.
  확신이 들지 않는 문제에 대해서 인지하는 것이 중요하다.
  ```
  ```
  위의 문자열 함수를 마찬가지로 만든다고 봤을 때
  구체화 해서 대문자는 소문자로 바꾸고 숫자도 문자열로 계산하고 등 자신만의 기준이나 문제에서 제시된 기준으로 설정하고
  단계별로 스텝을 작성해본다.
  1. 반환할 객체를 생성한다.
  2. 반복문을 돌면서 문자를 체크한다.(소문자로 변환해서 처리한다.)
    2-1. 반복문을 돌면서 객체의 key값이 반환할 객체 안에 있다면 거기에 + 1해준다.
    2-2. 객체안에 키값이 없으면 객체를 추가해준다.
    2-3. 문자가 공백, 마침표 등과 같은 다른 것이라면 아무것도 하지 않도록 한다.
  3. 객체를 반환하고 함수를 종료한다.
  ```
- 문제를 해결(solve)하거나 단순화하기(simplify)

  ```
  시간이 많이 걸리는 부분을 무시하고 빠르게 처리할 수 있는 부분부터 처리해라.
  진도를 나가지 못하는 부분은 과감하게 포기하고 추후에 진행할 수 있도록 하라.
  쉽게 정의할 수 잇는 부분은 쉽게 정리한 후 복잡한 부분으로 접근해라.
  ```

  ```
  마찬가지로 charCount함수를 진행해본다.
  키와 값으로 처리하는데 어려움이 있는 사람이거나, 대/소문자에 대한 처리를 하는것에 어려움을 겪는 사람들이 있을 것이다.
  이럴 떄는 객체로 처리하지 말고 모든 글자를 다 배열에 담거나 대/소문자를 무시하고 값을 처리하는 방법으로 진행하고 추후에 반환 값에 맞게 처리하는 것이다.
  이를 고려한 상태로 3번에서 세분화한 단계별로 코드를 작성해보자.
  // 첫번째 단순한 접근
  function charCount(str) {
    1. 반환할 객체를 생성한다.
    let result = {};
    2. 반복문을 돌면서 문자를 체크한다.
    for (let i = 0; i < str.length; i++){
      let char = str[i];
      2-1. 반복문을 돌면서 객체의 key값이 반환할 객체 안에 있다면 거기에 + 1해준다.
      if(result[char] > 0) {
        result[char]++;
      2-2. 객체안에 키값이 없으면 객체를 추가해준다.
      } else {
        result[char] = 1;
      }
    }
    3. 객체를 반환하고 함수를 종료한다.
    return result;
  }

  // 두번째 복잡한 접근(소문자 처리 + 문자열이 아닌 값 처리)
  function charCount(str) {
    1. 반환할 객체를 생성한다.
    let result = {};
    2. 반복문을 돌면서 문자를 체크한다. (+ 소문자로 변환 처리)
    for (let i = 0; i < str.length; i++){
      let char = str[i].toLowerCase();
      2-3. 문자가 공백, 마침표 등과 같은 다른 것이라면 아무것도 하지 않도록 한다.
      if(/[a-z0-9]/.test(char)){
        2-1. 반복문을 돌면서 객체의 key값이 반환할 객체 안에 있다면 거기에 + 1해준다.
        if(result[char] > 0) {
          result[char]++;
        2-2. 객체안에 키값이 없으면 객체를 추가해준다.
        } else {
          result[char] = 1;
        }
      }
    }
    3. 객체를 반환하고 함수를 종료한다.
    return result;
  }
  ```

- 문제를 복습(Look Back))하고 재구성하기(Refactor)

  ```
  문제의 해결법에 접근한 이후에는 한번 더 이 문제에 대해서 생각해보는 복기 과정이 굉장히 중요하다.
  결과를 확인할 수 있었는지?
  다른 방식으로 도출할 수 있는지?
  생각나는 다른 접근 방식이 있는지?
  앞서 생각하지 못한 다른 방법을 적용해볼 수 있는지?
  한눈에 보고 이해할 수 있는지?
  해결책이 얼마나 직관적인지?
  이 내용을 종이나 화이트보드로 옮겨도 이해할 수 있는지?
  이번 해결 방법을 다른 문제에도 적용해볼 수 있는지?
  코드 규칙을 잘 지키면서 작성하고 있는지?
  이러한 사고를 통해서 직관력을 기르는 것이 매우 중요하다.

  어떻게 더 성능을 향상시킬 수 있는지는 시간복잡도와 공간복잡도를 고려한다면 향상시킬 수 있다.
  ```

  ```
  그럼 charCount를 리팩토링 해보자.
  // 기존버전
  function charCount(str) {
    let result = {};
    for (let i = 0; i < str.length; i++){
      let char = str[i].toLowerCase();
      if(/[a-z0-9]/.test(char)){
        if(result[char] > 0) {
          result[char]++;
        } else {
          result[char] = 1;
        }
      }
    }
    return result;
  }

  // 리팩토링 버전
  // 해당 문자가 영어와 숫자인지 체크하는 함수
  function isAlphaNumeric(char) {
    // 아스키코드 숫자를 반환해주는 charCodeAt 메서드 활용
    let code = char.charCodeAt(0);
    // 해당하는 것들이 숫자나 영어 대소문자가 아니라면 false반환 맞으면 true 반환
    if(!(code > 47 && code < 58) && // numeric (0-9)
       !(code > 64 && code < 91) && // upper alpha(A-Z)
       !(code > 96 && code < 123)) { // lower alpha(a-z)
      return false;
    }
    return true;
  }

  function charCount(str) {
    let result = {};
    // for of 반복문을 활용해서 i인덱스 활용을 없애고 코드 가독성을 더 높이기
    for (let char of str) {
      // 문자가 맞으면 해당 로직 적용
      if (isAlphaNumeric(char)) {
        // 기존의 무조건 소문자로 바꾼 후 코드를 돌리는게 아니라 문자가 맞을 때만 돌리도록 진행
        char = char.toLowerCase();
        // if else로 길었던 로직을 논리 연산자를 통해서 정리
        // result[char] 이라는 값이 있다면 해당 값에 1이 더해지고
        // 없다면 1을 넣는 로직
        result[char] = ++result[char] || 1;
      }
    }
    return result
  }

  이렇게 다양한 메서드나 접근법을 생각해내서 코드를 가독성과 효율성 모두 좋은 코드로 정리 할 수 있다. 이러한 방식을 습관화한다면 앞으로 다양한 알고리즘 문제를 마주하더라도 빠르게 문제의 핵심을 파악하고 그에 대한 접근을 수월하게 할 수 있게 될 것이다.
  ```
