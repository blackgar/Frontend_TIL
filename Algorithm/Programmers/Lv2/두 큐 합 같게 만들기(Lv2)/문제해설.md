## 최초 접근 방식

최초에는 반복문 안에 shift()와 push()를 이용해서 문제에서 나온 말그대로 queue의 특성을 구현하려고 했다. 또한, 미리 배열의 합을 구해서 그 합에서 값을 더하고 빼면서 문제를 해결하고자 했다. 그리고 queue값을 서로 이동시키면서 합을 계산해 그 합을 비교한 값이 같을 때 정답을 반환하고, 각 queue의 길이의 합을 넘어서는 횟수를 반복할 경우 제자리로 돌아온다는 뜻이므로 -1을 반환하는 식으로 로직을 구현했다.

## 문제 발생

이렇게 접근했을 때 두 가지 문제가 발생했다. 첫 번째는 시간초과였다. 당연히 반복문 안에 shift()를 사용하면 n^2의 시간복잡도를 가지게 돼서 30만개까지 배열이 들어있는 경우가 있는데 이 때는 무조건 시간초과가 날 수 밖에 없었다. 그러므로 이를 줄일 수 있도록 하는 접근법이 필요했다. 또한, 내부적으로 무한루프를 돌 수 있는 문제도 있어서 이에 대한 조건 분기도 필요했다. 4번째 테스트케이스 참고

## 문제 해결

결국 queue는 배열의 가장 마지막 인덱스로 값이 들어오고 0번째 인덱스의 값이 나가는 구조이다. 그러면 push()의 경우 빅오 1의 시간복잡도 이니 사용해도 무방하고 shift()를 대신할 수 있는 방법이 필요했다. 이 때 어차피 현재 queue의 첫 번째 값만 잘 추적하면 되기 때문에, 다중포인터로 각 queue의 첫 번째 값을 지정하고 있으면 되지 않을까? 생각했다.
그렇게 첫 번째 값을 지정하고 있다가 queue에서 값을 내보내야 하는 상황이 오면 그 인덱스를 다음 값으로 옮겨서 지정해주고 값을 넣을 때는 push로 뒤에 값을 넣어주고자 했다. 어차피 인덱스를 추적하기 때문에 굳이 앞에 있는 값을 없앨 필요는 없기 때문에 그대로 두었다.
이렇게 반복문을 돌면서 계속 값을 비교해 나가다가 현재 추적하고 있는 인덱스가 처음 두 queue 중 더 큰 배열의 2배가 넘는 수를 추적한다는 것은 결국 모든 값을 비교하고도 제자리로 돌아왔다는 의미이므로 이때는 -1을 반환하는 조건을 넣어서 무한루프에서 벗어날 수 있도록 탈출 조건을 주어서 문제를 해결했다.
