## 최초 접근 방법

- 최초에는 하나의 배열을 돌면서 slice를 활용해 i까지의 값을 철수의 롤케잌, i이후의 토핑들을 동생의 롤케잌으로 지정하고 forEach로 철수의 롤케잌의 토핑개수와 동생의 토핑개수를 일일이 찾아서 비교해주다보니 시간복잡도가 n^2으로 최대 100만개의 input이 들어오게 되면 당연히 시간초과가 날 수 밖에 없는 접근으로 시도했다.

## 해결 방법

- 일일이 비교하기 보다는 일단 모든 토핑의 개수와 종류를 구해서 동생의 토핑으로 지정해놓고 철수가 토핑 하나씩을 가져갈 때마다 동생이 가지고 있는 토핑에서 빼주면 되겠다는 생각을 했다. 동생이 가지고 있는 토핑 객체(youngerObj)와 종류 개수(youngerToppings)를 계산해두고 for문을 돌면서 해당 토핑을 철수가 가지면서 철수가 새로운 토핑을 받을 때마다(olderObj) 철수가 가지고 있는 토핑 종류의 개수(olderToppings)를 더해주고 철수 토핑 종류수와 동생의 토핑 종류수를 비교해서 같을 때 값을 더해주고 만약 형이 더 많은 토핑을 가지게 되는 순간부터는 동생이 무조건 적은 수의 토핑 종류를 가지게 되므로 반복문을 멈추고 값을 반환하는 식으로 접근했다.
