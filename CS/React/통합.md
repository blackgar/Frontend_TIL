## React에 대해 설명해주세요.

- 자바스크립트 라이브러리입니다. 싱글 페이지 어플리케이션을 개발하는데 최적화 되어 있고 기존의 자바스크립트가 가지고 있던 직접적인 DOM을 조작해 모든 UI를 새롭게 갱신하는 방법을 개선해 동적으로 UI를 갱신할 수 있도록 할 수 있는 문제를 해결한 라이브러리입니다.

## React의 원리, 특징, 장단점이 무엇인가요?

-

## Virtual DOM 이 무엇인지 설명해주세요.

### DOM이란?

- 문서 객체 모델이라고 하며, 브라우저에서 다룰 HTML 문서를 파싱해 문서의 구성요소들을 객체로 구조화해 나타낸 것입니다.

### Virtual DOM이란?

- DOM을 추상화한 가상의 객체라고 표현할 수 있습니다. SPA의 특징으로 DOM의 복잡도가 증가하고 최적화와 유지보수의 어려움이 생기고 있고 DOM을 반복적으로 직접 조작하면 그만큼 브라우저가 랜더링을 빈번하게 해야 되므로 자원 소모가 커진다는 문제를 해결하기 위해 등장했습니다.

### 작동원리

- DOM을 추상화한 가상의 객체를 메모리에 만들어 놓고 변경내역을 한번에 모은다음 실제 DOM과 비교해 변경된 Virtual DOM과의 차이를 판단한 후에 구성요소의 변경이 일어난 부분만 찾아서 변경하고 그에 따른 렌더링을 한 번만 하는 방식으로 동작합니다. 예를들어 ul태그 안에 li태그가 10개씩 들어가서 리스트를 보여주는 UI가 있다고 가정했을 때 다음페이지를 누르게 되면 기존에는 li태그 10개를 10번의 수정을 통해 UI를 랜더링 했다고 하면 virtual dom은 변경사항을 모두 저장한다음 변경된 li태그 10개를 ul태그 하나만 변경해서 랜더링 1번으로 UI를 갱신할 수 있게 됩니다.
-

## Virtual DOM 작동 원리에 대해 설명해주세요.

-

## ⭐ JSX에 대해 설명해주세요.

- Javascript에 XML을 추가한 확장문법입니다. 리액트로 개발할 때 사용되기 때문에 공식적인 자바스크립트 문법은 아닙니다. 브라우저에서 실행하기 전에 바벨을 사용해서 일반 자바스크립트 형태의 코드로 변환됩니다. 장점으로는 가독성과 코드의 효율성을 가져갈 수 있다는 점입니다.

## 엘리먼트와 컴포넌트의 차이에 대해 설명해주세요.

-

## 리액트에서 컴포넌트를 어떻게 생성하나요?

-

## 클래스형 컴포넌트를 사용해보셨나요?

-

## ⭐ 클래스형 컴포넌트와 함수형 컴포넌트의 차이에 대해 설명해주세요.

-

## ⭐ 라이프사이클에 대해 설명해주세요.

- 기본적으로 mount -> update -> unmount 생명주기를 갖는다. 리액트의 클래스 컴포넌트는 라이프 사이클 메서드를 사용하고, 함수형 컴포넌트는 hook을 사용합니다.

## ⭐ 라이프 사이클 메소드에 대해 설명해주세요.

### 생성

- constructor : 생성자로 초기 상태값을 정할 수 있습니다. 클래스에서는 constructor을 사용하고 함수형 컴포넌트에서는 useState를 사용하면 쉽게 초기 상태를 정할 수 있습니다.
- getDerivedStateFromProps : props로부터 파생된 state를 가져옵니다. 즉 props 받아온 것을 state에 넣어주고 싶을 때 사용합니다.
- render : 가장 기초적인 메서드이면서 중요한 메서드입니다. 컴포넌트를 렌더링할 때 필요한 메서드이면서 유일한 필수 메서드입니다.
- componentDidMount : 첫번째 렌더링이 끝나고 호출되는 메서드입니다. 이 메서드가 호출되는 시점에는 화면에 컴포넌트가 나타난 상태입니다.

### 업데이트

- getDerivedStateFromProps : props로부터 파생된 state를 가져옵니다. 즉 props 받아온 것을 state에 넣어주고 싶을 때 사용합니다.
- shouldComponentUpdate : props나 state를 변경했을 때, 리렌더링 여부에 대해 결정하는 메서드입니다.
- render : 가장 기초적인 메서드이면서 중요한 메서드입니다. 컴포넌트를 렌더링할 때 필요한 메서드이면서 유일한 필수 메서드입니다.
- getSnapshotBeforeUpdate : render에서 만들어진 결과가 브라우저에 실제로 반영되기 직전에 호출됩니다. 흔히 사용하지는 않지만, 채팅 화면처럼 스크롤 위치를 따로 처리할 때 필요합니다.
- componentDidUpdate : 리렌더링이 마치고, 화면에 우리가 원하는 변화가 모두 반영되고 난 뒤 호출되는 메서드입니다. 3번째 파라미터로 getSnapshotBeforeUpdate 에서 반환한 값을 조회 할 수 있습니다.

### 제거

- componentWillUnmount : 컴포넌트가 화면에서 사라지기 직전에 호출됩니다. DOM에 등록했던 이벤트를 제거하고 setTimeout과 같은 것들을 clear 해줍니다.

## ⭐ 함수형 컴포넌트의 장점에 대해 설명해주세요.

-

## ⭐ React Hooks에 대해 설명해주세요.

- 함수형 컴포넌트에서 React state와 생명주기 기능을 연동할 수 있게 해주는 함수입니다.
- 라이프사이클 메서드 기반이 아닌 로직을 기반으로 컴포넌트를 함수 단위로 잘게 쪼갤 수 있다는 장점이 있습니다.
- 라이프 사이클 메서드에는 관련 없는 로직이 섞여 들어가는 경우가 많은데, 무결성을 해치는 문제를 해결했습니다.
- 최상위에서만 Hook을 호출해야 하고 함수형 컴포넌트에서만 Hook을 호출해야 한다는 규칙이 있습니다.

## ⭐ 함수형 컴포넌트에서 클래스형 컴포넌트의 라이프 사이클 메소드를 비슷하게 사용하는

- useState : 상태를 관리합니다.
- useEffect : 화면에 렌더링이 완료된 이후에 수행되며 componentDidMount, componentDidUpdate, componentWillUnmount가 합쳐진 것입니다. useEffect 안에 의존성 배열이 없는 경우에는 렌더링 결과가 실제 돔에 반영된 순간마다 호출되고, 의존성 배열을 비워둔채로 두면 컴포넌트가 처음 나타날때 한 번 호출하게 되고, 의존성 배열안에 값을 넣게 되면 조건부로 의존성 중 하나가 변경될 때마다 내부 로직이 실행되게 됩니다.
- 방법에 대해 설명해주세요. (useEffect => ComponentDidMount, ComponentDidUpdate, ComponentWillUnmount)

## useEffect와 useLayoutEffect의 차이점에 대해 설명해주세요.

- useEffect는 렌더링이 완료된 후에 수행된다면 화면이 모두 렌더링 되기 전에 동기화 시켜야할 로직이 필요한 경우에는 useLayoutEffect를 사용해서 컴포넌트 렌더링 - useLayoutEffect - 화면 업데이트 순으로 실행시킬 수 있습니다.

## Pure Component에 대해 설명해주세요.

-

## shouldComponentUpdate에 대해 설명해주세요.

-

## State에 대해 설명해주세요.

-

## React에서 State를 어떻게 관리하나요?

- 불변성을 원칙으로 deep copy를 통한 state 관리를 진행합니다. 하나의 객체나 값을 변경하게 되면 이를 참조하는 객체의 값도 변동되는 문제를 deep copy로 독립된 상수로 지정해서 해당 값만 변경될 수 있도록 관리하는 것입니다.

## Props에 대해 설명해주세요.

-

## ⭐ Props Drilling에 대해 설명해주세요.

-

## ⭐ Props Drilling을 어떻게 해결할 수 있나요?

-

## 데이터를 자식에서 부모로도 전달할 수 있나요?

-

## Props와 State의 차이에 대해 설명해주세요.

-

## 왜 state를 직접 바꾸지 않고 setState (useState)를 사용해야 하나요?

-

## React 에서 상태 변화가 생겼을 때, 변화를 어떻게 알아채는지에 대해 설명해주세요.

-

## React에서 State의 불변성은 어떻게 유지할 수 있나요?

-

## setState는 동기적으로 동작하나요? 아니면 비동기적으로 동작하나요?

-

## 왜 비동기적으로 동작하나요?

-

## HTML과 React의 이벤트 처리 차이점에 대해 설명해주세요.

-

## ⭐ Key Props를 사용하는 이유에 대해 설명해주세요.

-

## Ref의 용도에 대해 설명해주세요.

-

## ⭐ 제어 컴포넌트와 비제어 컴포넌트의 차이에 대해 설명해주세요.

-

## HOC (Higher-Order Components)에 대해 설명해주세요.

-

## Context API에 대해 설명해주세요.

-

## React.Fragment에 대해 설명해주세요.

-

## Portal에 대해 설명해주세요.

-

## 에러 바운더리에 대해 설명해주세요.

-

## 메모이제이션에 대해 설명해주세요.

- 기존에 수행한 연산의 결과값을 저장해두고 동일한 입력이 들어올때 재활용하는 프로그래밍 기법

## ⭐ 리액트에서 메모이제이션을 어떤 방식으로 활용할 수 있나요?

- useMemo, useCallback과 같은 훅으로 공통적으로 자주 사용되는 값이나 함수를 저장해두고 만약 변경된 로직이 적용되어야 할 때 변경해서 사용할 수 있도록 저장해서 사용이 가능합니다.

## ⭐ useMemo와 useCallback에 대해 설명해주세요.

### useMemo

- 어떤 값이 연산을 통해서 정해진다면, 렌더링 될 때마다 다시 연산이 되면 자원이 낭비됩니다. 이를 해결 하기 위해서 연산된 값이 변경되지 않는다면, 이러한 값을 저장해두고 새로운 연산없이 바로 사용할 수 있도록 저장해두고 사용할 수 있는 값을 반환하는 hook입니다.

### useCallback

- 콜백함수를 저장해서 의존성에 의해 변경이 있을 때만 새로운 콜백함수로 저장해서 다시 재사용할 수 있게 합니다.

## React.memo와 useMemo의 차이에 대해 설명해주세요.

- React.memo는 HOC(컴포넌트를 인자로 받아서 새로운 컴포넌트를 return해주는 함수)입니다. 만약 같은 props를 받을 때 같은 결과를 렌더링 한다면 react.memo를 사용해 불필요한 컴포넌트 렌더링을 방지할 수 있습니다. 오직 props의 변경 유무만 확인하고 변경됐다면 새로운 컴포넌트를 생성해 렌더링합니다. 비교함수를 두번째 인자로 넣을 수 있습니다.
- 차이점은 HOC는 클래스형, 함수형에 모두 사용가능하지만, useMemo는 함수형 컴포넌트에서만 사용이 가능합니다.

## 리액트 관련 패키지 중에 제일 좋다고 생각한 것은 무엇인가요?

-

## 리액트의 렌더링 성능 향상을 위해 어떻게 해야 하나요?

-

## CSS in JS를 사용해 본 적이 있나요? 있다면 소감을 말해주세요.

-

## React 18 버전 업데이트 내용에 대해 말씀해주세요.

-

## Client Side Routing에 대해 설명해주세요.

-

## Next.js 를 사용해보셨나요?

-

## React에서 Form 이벤트는 어떻게 제어하셨나요?

-

## React Hook Form 를 사용해보셨나요?

-

## 기억나는 Hook에 대해 전부 설명해주세요.

-

## React에서 컴포넌트 A가 사용하는 CSS파일과 컴포넌트 B가 사용하는 CSS파일의 선택자가

- 겹치는 이유가 뭘까요?

## ⭐ Redux에 대해 설명해주세요.

-

## ⭐ Redux를 사용하는 이유에 대해 설명해주세요.

-

## ⭐ Redux의 장단점에 대해 설명해주세요.

-

## Flux 패턴에 대해 설명해주세요.

-

## Context API와 Redux를 비교해주세요.

-

## Redux의 3대 원칙에 대해 설명해주세요.

-

## React-Query를 사용해보셨나요?

-

## React-Query에 대해 설명해주세요.

-

## React-Query의 등장 배경과 장점에 대해 설명해주세요.

-

## Recoil을 사용해보셨나요?

-

## Recoil에 대해 설명해주세요.

-

## Recoil에서 Loadable의 개념에 대해 설명해주세요.

-

## Recoil에서 비동기로 데이터를 받아올 때 State를 어떻게 관리하셨나요?

-

## Recoil에서 로딩, 성공, 에러와 관련된 처리를 어떻게 하셨나요?

-

## ⭐ Redux와 Recoil에 대해 비교 설명해주세요. (개념, 장단점)

### Recoil

- context API 기반 함수형 컴포넌트에서만 사용 가능. 배우기 쉽고 내장된 Hooks와 사용법이 유사하다는 장점이 있습니다. redux와 다르게 비동기 처리를 기반으로 하기 때문에 동시성 모드를 제공해 비동기 처리 라이브러리를 추가적으로 설치할 필요가 없습니다.

### Redux

- Action은 state를 바꾸는 방식
- Dispatch는 Action을 발생시키는 것
- Reducer은 변화를 일으키는 함수로 Action의 결과로 state를 어떤식으로 바꿀지에 대해 구체적으로 정의하는 부분, 이전 상태는 건드리지 않고 새로운 상태객체를 만들어 반환하는 순수함수
- Store은 상태의 중앙저장소라고 보면된다. store안에 reducer와 같은 내장함수 등이 포함되어 있다.
- 상태를 전역적으로 관리하기에 어느 컴포넌트에 상태를 둬야할지 고민할 필요가 없다. 단방향 데이터 흐름, 불변성 유지가 매우 중요, flux아키텍처를 따른다. 여러 라이브러리를 동시에 사용, 액션하나를 추가하는데 작성이 필요한 부분이 많고 컴포넌트와 스토어를 연결하는 필수적인 부분들이 있어 코드량이 많아질 수 있다는 특징이 있다.
