# 자바스크립트 면접 질문 정리

## 자바스크립트는 무슨 언어인가요?

-

## 변수 선언, 초기화, 할당의 차이점에 대해 설명해주세요.

-

## 데이터 타입에 대해 설명해주세요.

-

## 생성자에 대해 설명해주세요.

-

## ⭐ this에 대해 설명해주세요.

### this란?

- javascript의 예약어입니다.
- this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(self-reference variable)입니다.
- this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있습니다.
- 자바스크립트 엔진에 의해 암묵적으로 생성됩니다.
- this는 코드 어디서든 참조할 수 있습니다.
- 함수를 호출하면 인자와 this가 암묵적으로 함수 내부에 전달됩니다. 인자와 this를 모두 지역 변수처럼 활용할 수 있습니다.
- this 바인딩은 함수 호출 방식에 의해 동적으로 결정됩니다. 어떤 위치에 있는지, 어디서 호출하는지, 어떤 함수에 있는지에 따라 참조값이 달라지는 특징이 있어 이에 대한 이해가 필수입니다.

### 바인딩이란?

- 식별자와 값을 연결하는 과정을 의미합니다.
- 변수선언은 변수 이름과 확보된 메모리 공간의 주소를 바인딩하는 것입니다.
- this바인딩은 this(키워드로 분류되지만 식별자의 역할을 합니다)와 this가 가리킬 객체를 바인딩하는 것입니다.
- 전역에서의 this는 window 전역 객체를 참조합니다.
- 함수는 전역에 선언된 일반 함수와 객체 안의 메소드로 구분할 수 있습니다.
- 엄격모드의 this는 undefined가 바인딩 됩니다.

## call, apply, bind에 대해 설명해주세요.

-

## ⭐ 콜백 함수에 대해 설명해주세요.

- 다른 함수가 실행을 끝낸 뒤에 실행되는 함수를 의미합니다. 즉, 함수는 다른 함수의 인자로 쓰일 수도 있고 반환값으로 반환할수도 있습니다. 이런 함수를 고차함수라고 하는데, 이 때 인자로 넘겨지는 함수를 콜백함수라고 합니다. 또한, 함수를 등록해놓고 특정 이벤트나 시점에 의해 시스템에서 호출되는 함수도 콜백함수라고 합니다.

## ⭐ 콜백 지옥을 해결하는 방법을 설명해주세요.

- Promise나 async를 활용하는 방법이 있습니다.

## ⭐ Promise에 대해 설명해주세요.

- 비동기 연산이 종료된 이후에 결과를 알기 위해 사용하는 객체입니다(ES6). 이를 사용해 비동기 메서드를 마치 동기 메서드처럼 값을 반환할 수 있습니다. then과 catch의 체이닝을 통해 값을 반환 받아올 수 있습니다. 즉, 내용은 실행됐지만 결과를 아직 반환하지 않은 객체입니다.
- Promise는 대기(pending), 이행(fulfill), 거부(reject) 세 가지 상태 중 하나를 가지고 있습니다. Promise 기반 비동기 함수를 호출하게 되면 그 함수는 Promise 인스턴스를 반환하는데 이행되거나 거부될 때 Promise의 then과 catch 메서드에 의해 대기열에 추가된 처리기들이 호출됩니다.
- then(호출 성공시), catch(호출 실패시), finally(공통적으로 수행해야할 부분 처리)

## Promise.all() 에 대해 설명해주세요.

- 배열과 같이 순회 가능한 객체를 인자로 받습니다. 해당 배열안의 프로미스가 모두 이행되면 각각의 프로미스 결과 값을 담은 배열을 이행 결과 값으로 새로운 프로미스 객체를 반환합니다. 하지만, 이 때 배열 요소 중 하나의 프로미스라도 거부되는 즉시 다른 프로미스 이행 여부와 관계없이 거부 사유를 결과 값으로 반환합니다.

## ⭐ Promise와 Callback를 비교 설명해주세요.

- callback을 사용해 비동기 처리를 할 때는 결과값을 리턴 받기보다는 결과값을 통해 처리할 로직을 콜백 함수로 넘기는 스타일로 코딩을 해줘야 예상된 결과를 얻을 수 있습니다. 즉, 비동기 로직의 결과값을 처리하기 위해서 callback 안에서만 처리를 해야하는 문제가 있습니다. 하지만, 자바스크립트 프로젝트가 복잡해질수록 콜백 함수를 중첩해서 사용하게 되고 이는 가독성을 떨어지게 하는 문제를 야기합니다.

## ⭐ Async, Await이 뭔지 그리고 사용 방법을 설명해주세요.

- ES8부터 도입된 비동기함수 처리 방법입니다. Promise의 후속처리 메서드(then, catch, finally)없이 마치 동기적인 코드처럼 Promise가 처리결과를 반환하도록 구현할 수 있는 방법입니다. 비동기 함수는 항상 Promise객체를 반환하는데 async 함수는 언제나 async 키워드를 사용해 언제나 Promise를 반환합니다. 이 때 암묵적으로 반환값을 resolve하는 Promise를 반환합니다.
- await는 async 안에서만 작동합니다. await 키워드를 쓰게 되면 해당값이 반환되기 전까지 async 내부 함수는 일시 중단이 됩니다. Promise가 settled(수행완료) 상태가 될때까지 대기하다가 resolve한 처리결과 값을 반환합니다. 에러의 경우 try catch 구문으로 에러를 감지합니다.

## ⭐ Promise와 Async, Await의 차이를 설명해주세요.

- 에러 핸들링에서 Promise는 reject될경우 .catch()문을 통해 에러를 감지할 수 있지만, async/await의 경우 try-catch문을 사용해야 합니다. 다만, 전체적인 에러핸들링은 async가 유리합니다. 데이터는 받아왔지만 json.parse과정에서 문제가 발생할 경우 Promise 객체의 경우 then문 안에 catch문을 추가로 작성해야 하지만, async는 try catch문 한번이면 에러 핸들링이 가능합니다. 또한 에러 위치도 더 잘 알려주기에 에러핸들링을 위해서는 async await를 사용하는 것이 좋습니다.
- 코드 가독성의 경우 Promise는 .then()의 지옥 가능성이 있는 반면에 코드가 길어질수록 async/await의 가독성이 좋아집니다. 코드 흐름을 이해하기엔 async/await가 유리합니다.

## AJAX에 대해 설명해주세요.

-

## ⭐ var, let, const 차이를 설명해주세요.

- var 선언과 초기화를 최상단에서 진행. 할당은 코드로 왔을 때. 재선언 재할당 가능, 함수 스코프인 자바스크립트 특징으로 인해서 미처 변수가 선언되기도 전에 유효하다고 판정되기 때문에 호이스팅이 발생합니다.
- let 선언을 최상단에서 진행. 초기화와 할당이 코드에서 진행. 재선언 불가 재할당 가능, 블록 스코프
- const 선언, 초기화, 할당 모두 코드라인에서 진행. 재선언 불가 재할당 불가

## TDZ에 대해 설명해주세요.

-

## 함수 선언형과 함수 표현식의 차이에 대해 설명해주세요.

-

## ⭐ 이벤트 버블링과 캡처링에 대해 설명해주세요.

- 이벤트 버블링이란 자식태그에서 발생한 이벤트가 조상 태그까지 퍼지는 것. 캡쳐링은 반대로 부모태그에서 발생한 이벤트가 자식태그로 가는 것. stopPropagation으로 막을 수 있다.

## ⭐ 이벤트 위임에 대해서 설명해주세요.

- 하위 요소마다 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식을 말합니다. 이벤트 위임을 사용할 경우 요소마다 핸들러를 할당하지 않고도 공통 조상에 이벤트 핸들러를 할당하면 여러 요소를 한꺼번에 다룰 수 있다는 장점이 있습니다. 이를 위해서는 event target과 currentTarget 값을 이해하고 이 값을 적절하게 활용해서 코드를 작성하면 된다.

## 이벤트 위임의 동작 방식에 대해서 설명해주세요.

-

## ⭐ 호이스팅과 발생하는 이유에 대해 설명해주세요.

- 호이스팅이란 var로 선언한 표현식이나 function 선언문 등을 실행 단계에서 해당 scope의 최 상단으로 올려서 실행하는 부분을 말합니다. 자바스크립트는 코드를 실행하기 전에 var 선언문과 function 선언문을 해당 스코프의 최상단으로 올리는 이유는 자바스크립트 변수 생성과 초기화 즉, 선언과 초기화와 할당이 분리되어 진행되기 때문입니다. 주의할 부분은 변수에 값이 초기화 및 할당이 되어 있는지 여부에 따라 var과 function 선언문이 다르게 동작합니다.

```
<!-- 값이 있다면 기존의 값이 함수를 덮습니다. -->
var getName = 'olaf';
function getName(){
  console.log('olaf');
}
console.log(typeof getName); // string

<!-- 반면에 undefined 일 경우 함수가 채워줍니다. -->
var getName; // undefined
function getName() {
     console.log("appear");
}
console.log(typeof getName); // function
```

## 스코프 (Scope)에 대해 설명해주세요.

- 해당 변수가 정의되어 있는 영역, 즉 정의된 변수를 사용할 수 있는 소스코드의 집합을 말합니다. 자바스크립트는 기본적으로 함수 스코프를 사용하므로 함수 내에 정의된 변수는 해당 함수 내에서만 사용할 수 있고 유효합니다.

## 스코프 체인에 대해 설명해주세요.

- 전역 변수는 전역 객체의 프로퍼티입니다. 지역 변수는 그런 규정이 없지만, 변수를 각 함수 호출과 연관된 객체의 프로퍼티로 생각할 수 있습니다. 그래서 지역 변수를 한 객체의 프로퍼티라고 생각할 때, 자바스크립트의 모든 코드는 스코프 체인을 가지고 있습니다. 이러한 코드의 유효 범위 안에 있는 변수를 정의하는 객체의 체인, 즉 리스트를 말합니다.
- 자바스크립트가 변수의 값을 얻으려고 할 때 스코프 체인은 객체의 리스트이므로 첫 번째 객체에서 변수를 찾아보고 없으면 그다음 객체를 찾아보는 식으로 모든 객체를 탐색했는데도 해당 변수가 없다면 reference error을 반환합니다.

## ⭐ 클로져(Closure)에 대해 설명해주세요.

- 클로저를 이해하기 위해서는 렉시컬 스코프에 대해서도 이해해야 한다.

### 렉시컬 스코프란?

- 함수가 정의된 시점의 스코프 체인을 사용해서 함수가 실행되는 규칙입니다. 중요한 것은 함수가 호출된 시점이 아니라 정의된 시점이라는 것인데, 한 예로 어떠한 함수가 함수내의 지역 변수를 사용하여 또다른 함수를 반환한다고 가정했을 때 이 함수가 호출 시점보다 전에 있으면 함수가 먼저 실행돼서 함수 내의 지역변수가 사라질 것이라고 생각할 수 있지만, 그렇지 않고 함수가 정의되었을 때의 스코프 체인을 사용해서 함수가 정의되었을 때 바인딩 된 지역변수를 활용해 리턴된 함수가 동작하게 됩니다.
- 즉, 함수가 호출되면 호출과 관련된 지역 변수를 보관하는 객체가 생성되고 이 객체는 함수의 스코프 체인에 추가됩니다. 이후 함수가 반환되면 보관하던 객체가 사라지고 바인딩된 변수가 스코프 체인에서 제거됩니다. inner 함수가 있을 때는 스코프 체인에 대한 참조가 있고 이 스코프 체인은 객체와 바인딩된 변수들을 참조하고 있습니다.

```
function wrapElements(a) {
  var result = [], i, n;
  for (i = 0, n = a.length; i < n; i++) {
    result[i] = function () { return a[i]; }
  }
  return result;
}
var wrapped = wrapElements([10, 20, 30, 40, 50]);
var f = wrapped[0];
f(); // undefined

<!-- let으로 선언 -->
function wrapElements(a) {
  var result = [], n;
  for (let i = 0, n = a.length; i < n; i++) {
    result[i] = function () { return a[i]; }
  }
  return result;
}
var wrapped = wrapElements([10, 20, 30, 40, 50]);
var f = wrapped[0];
f(); // 10
```

- 위 예시에서 확인할 수 있듯이 이미 함수가 먼저 동작하므로 i는 5가된 상태로 wrapped라는 변수에 함수가 호출됩니다. i는 5인 상태로 함수가 호출됐기 때문에 내부 코드에서 보면 a[5] 값은 없기 때문에 undefined를 반환합니다. 이 때 원하는 결과를 얻기 위해서는 i를 let으로 선언하게 되면 블록 스코프로 지역 변수를 사용하기 때문에 공유하지 못하는 현상으로 인해 함수가 호출될 때 매번 새로운 값으로 돌아가므로 정상적으로 f() 값이 10이 나오게 된다.

## 실행 컨텍스트에 대해 설명해주세요.

-

## 렉시컬 환경(Lexical Environment)에 대해 설명해주세요.

-

## 자바스크립트에서 일어나는 데이터 형변환에 대해 설명해주세요.

-

## 자바스크립트가 동적 언어인 이유는 무엇인가요?

-

## 프로토타입에 대해 설명해주세요.

-

## 깊은 복사와 얕은 복사에 대해 설명해주세요.

-

## 불변성을 유지하려면 어떻게 해야하나요?

-

## Blocking과 Non- Blocking에 대해 설명해주세요.

-

## ⭐ 동기와 비동기에 대해 설명해주세요.

-

## ES6에서 새로 생긴 기능을 아는대로 말씀해주세요.

-

## undefined, null, undeclared를 비교해주세요.

-

## 자바스크립트를 멀티 쓰레드처럼 사용하는 방법이 뭔가요? / 자바스크립트에서 비동기 로직이

### 이벤트 루프란?

- 함수가 호출되면 call stack에 추가가 되고 내부 로직들이 한줄씩 call stack에 들어와서 처리되는 동기식 처리가 진행됩니다. 그러다가 setTimeout과 같은 비동기로 처리해야 되는 함수가 call stack으로 들어오게 되면 브라우저가 제공하는 webAPI를 통해 대기열Queue에 들어가게 되고 event Loop는 callstack이 모두 비워지면 대기열 Queue에 있던 함수들을 callstack으로 다시 넣어서 실행시키는 역할을 합니다.
- Heap : 메모리 할당이 발생하는 곳
- Call Stack : 실행된 코드의 환경을 저장하는 자료구조로, 함수 호출 시 이곳에 저장된다. 어떤 함수를 저장하면 스택에 쌓고 또 다른 함수를 호출하면 그 다음 스택에 쌓이면서 가장 위에 쌓인 함수를 가장 먼저 처리한다. LIFO(Last In First Out)
- Web APIs : Web API는 브라우저에서 제공하는 API로 DOM, Ajax, TimeOut 등이 있다.
  CallStack에서 실행된 비동기 함수는 Web API를 호출하고, Web API는 콜백 함수를 Task Queue에 넣는다.
- Callback Queue : 함수를 저장하는 자료구조로, Call Stack과 다르게 가장 먼저 들어온 함수를 가장 먼저 처리한다.
- Event Loop : 이벤트 루프는 call stack이 다 비워지면 callback queue에 존재하는 함수를 하나씩 call stack으로 옮기는 역할을 한다.

-

## 태스크 큐와 마이크로 태스트 큐에는 어떤 함수가 들어가나요?

-

## requestAnimationFrame에 대해 설명해주세요.

-

## 비동기적으로 실행되는 것을 동기적으로 코딩하는 방법이 있나요?

-

## map과 forEach, reduce에 대해 설명해주세요.

-

## 자바스크립트의 메모리 관리에 대해 아는 대로 설명해주세요

-

## 클래스에 대해 설명해주세요.

-

## 즉시 실행 함수 (IIFE)에 대해 설명해주세요.

-

## 엄격 모드에 대해 설명해주세요.

-

## 콜 스택 (Call Stack)과 힙 (Heap)에 대해 설명해주세요.

-

## Rest 연산자와 Spread 연산자에 대해 설명해주세요.

-

## 제너레이터에 대해 설명해주세요.

-

## 이터러블과 이터레이터 프로토콜에 대해 설명해주세요.

-

-

## 자바스크립트 자료구조에 대해서 아는대로 설명해주세요.

-
